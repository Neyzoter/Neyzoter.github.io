<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="layout" content="wiki">
<meta name="description" content="Java语法">
<meta name="categories" content="Java">
<meta name="keywords" content="Java"><style>body {
  max-width: 980px;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAABE0AA8AAAAAHWwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY3d1HZY21hcAAAAdgAAACqAAACOvWLi0FjdnQgAAAChAAAABMAAAAgBtX/BGZwZ20AAAKYAAAFkAAAC3CKkZBZZ2FzcAAACCgAAAAIAAAACAAAABBnbHlmAAAIMAAABdQAAAjkYT9TNWhlYWQAAA4EAAAAMwAAADYQ6WvNaGhlYQAADjgAAAAfAAAAJAc6A1pobXR4AAAOWAAAACAAAAA0Kmz/7mxvY2EAAA54AAAAHAAAABwQPBJubWF4cAAADpQAAAAgAAAAIAEHC/NuYW1lAAAOtAAAAYQAAALxhQT4h3Bvc3QAABA4AAAAfgAAAMS3SYh9cHJlcAAAELgAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZHZmnMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4Pwz+yMwf9z2KIYg5imAYUZgTJAQDcoQvQAHic7ZHNDYJAFIRnBXf94cDRIiyCKkCpwFCPJ092RcKNDoYKcN4+EmMPvpdvk539zQyAPYBCXEUJhBcCrJ5SQ9YLnLJe4qF5rdb+uWPDngNHTkta101pNyWa8lMhn6xx2dqUnW4q9YOIhAOOeueMSgsR/6ry+P7O5s6xVNg4chBsHUuFnWNJ8uZYwrw7chrsHXkODo7cB0dHOYCTY8kv0VE2WJKD6gOlWjsxAAB4nGNgQAMSEMgc9D8LhAESbAPdAHicrVZpd9NGFB15SZyELCULLWphxMRpsEYmbMGACUGyYyBdnK2VoIsUO+m+8Ynf4F/zZNpz6Dd+Wu8bLySQtOdwmpOjd+fN1czbZRJaktgL65GUmy/F1NYmjew8CemGTctRfCg7eyFlisnfBVEQrZbatx2HREQiULWusEQQ+x5ZmmR86FFGy7akV03KLT3pLlvjQb1V334aOsqxO6GkZjN0aD2yJVUYVaJIpj1S0qZlqPorSSu8v8LMV81QwohOImm8GcbQSN4bZ7TKaDW24yiKbLLcKFIkmuFBFHmU1RLn5IoJDMoHzZDyyqcR5cP8iKzYo5xWsEu20/y+L3mndzk/sV9vUbbkQB/Ijuzg7HQlX4RbW2HctJPtKFQRdtd3QmzZ7FT/Zo/ymkYDtysyvdCMYKl8hRArP6HM/iFZLZxP+ZJHo1qykRNB62VO7Es+gdbjiClxzRhZ0N3RCRHU/ZIzDPaYPh788d4plgsTAngcy3pHJZwIEylhczRJ2jByYCVliyqp9a6YOOV1WsRbwn7t2tGXzmjjUHdiPFsPHVs5UcnxaFKnmUyd2knNoykNopR0JnjMrwMoP6JJXm1jNYmVR9M4ZsaERCICLdxLU0EsO7GkKQTNoxm9uRumuXYtWqTJA/Xco/f05la4udNT2g70s0Z/VqdiOtgL0+lp5C/xadrlIkXp+ukZfkziQdYCMpEtNsOUgwdv/Q7Sy9eWHIXXBtju7fMrqH3WRPCkAfsb0B5P1SkJTIWYVYhWQGKta1mWydWsFqnI1HdDmla+rNMEinIcF8e+jHH9XzMzlpgSvt+J07MjLj1z7UsI0xx8m3U9mtepxXIBcWZ5TqdZlu/rNMfyA53mWZ7X6QhLW6ejLD/UaYHlRzodY3lBC5p038GQizDkAg6QMISlA0NYXoIhLBUMYbkIQ1gWYQjLJRjC8mMYwnIZhrC8rGXV1FNJ49qZWAZsQmBijh65zEXlaiq5VEK7aFRqQ54SbpVUFM+qf2WgXjzyhjmwFkiXyJpfMc6Vj0bl+NYVLW8aO1fAsepvH472OfFS1ouFPwX/1dZUJb1izcOTq/Abhp5sJ6o2qXh0TZfPVT26/l9UVFgL9BtIhVgoyrJscGcihI86nYZqoJVDzGzMPLTrdcuan8P9NzFCFlD9+DcUGgvcg05ZSVnt4KzV19uy3DuDcjgTLEkxN/P6VvgiI7PSfpFZyp6PfB5wBYxKZdhqA60VvNknMQ+Z3iTPBHFbUTZI2tjOBIkNHPOAefOdBCZh6qoN5E7hhg34BWFuwXknXKJ6oyyH7kXs8yik/Fun4kT2qGiMwLPZG2Gv70LKb3EMJDT5pX4MVBWhqRg1FdA0Um6oBl/G2bptQsYO9CMqdsOyrOLDxxb3lZJtGYR8pIjVo6Of1l6iTqrcfmYUl++dvgXBIDUxf3vfdHGQyrtayTJHbQNTtxqVU9eaQ+NVh+rmUfW94+wTOWuabronHnpf06rbwcVcLLD2bQ7SUiYX1PVhhQ2iy8WlUOplNEnvuAcYFhjQ71CKjf+r+th8nitVhdFxJN9O1LfR52AM/A/Yf0f1A9D3Y+hyDS7P95oTn2704WyZrqIX66foNzBrrblZugbc0HQD4iFHrY64yg18pwZxeqS5HOkh4GPdFeIBwCaAxeAT3bWM5lMAo/mMOT7A58xh0GQOgy3mMNhmzhrADnMY7DKHwR5zGHzBnHWAL5nDIGQOg4g5DJ4wJwB4yhwGXzGHwdfMYfANc+4DfMscBjFzGCTMYbCv6dYwzC1e0F2gtkFVoANTT1jcw+JQU2XI/o4Xhv29Qcz+wSCm/qjp9pD6Ey8M9WeDmPqLQUz9VdOdIfU3Xhjq7wYx9Q+DmPpMvxjLZQa/jHyXCgeUXWw+5++J9w/bxUC5AAEAAf//AA94nIVVX2hbZRQ/5/t7893s5ja9f7ouzdZ0TTqz3bRJmogbWya6bG6Cq0VbSV2ddIJjFtfIQHEig80Hda8yUN/0YQz8AyriiyD+xQd92R4HCnaCb3samnpumrpsCsLlfPf7zvedc37nL3CAtc/5W/wQZGA3tOBSY/g+TMjHmwzEoM1Q8+ZjRZY4oJhmBw5/YB6Za0yC5AkhlwA1A1yCBIBOwCII0Cj0U8BAMdUCzq05sKwkP7SlUY6fcJk4Fb/RyE79/6P5hjM/F4aZiXBoeMgzcqQ4Xi1hPqfDLG5FT+lchCVU3lYMyvuwhl1mqndQL0RsuloLywHtthLXI06OblTrhfWVnpSJ5+mwu/JdbtuN3IAnkW0LLMcRwaC7ktrlzridM6kVdyf9uO1UNBByI7JhwtG2sEwab07ORBeilWhqavJCqV0qzZTOl/7ZXQ5TbTcdcFelyGhhRDAQpdqp1FEX3w3cFTc1k9pJQkmm4ySCbSikxRP2QOfN+0tHS5MrpQuTU1Mk5nw0E5Xa0WvrOwDyGax9yB9ma6DAg82wHc43SAGTI4GjBWebOePAERFE8/AHaQpZASSTy8A4WwZiLQMQ82mFKATO0ILicRAoDm9p5P99E5b/fXG+kQYY3TYUuqmERWYoT0u/GNYL2q/4WB3LaVS+VynXsVYIcWw6DkCh3nX1D+VzlYN4LClF5yexSQos8exqZ3KVP+wtrC54u4Nznq6cq+xpMpUUnZ8FUYzE86ud0g28NOIv3Gj5/rmA3ABs7S/ywzFuQ4qyd6QxfNtiQIaEgp3w/entQg4Vcbqa16M5FfpeUB8t1+qeg7mI7cUyOe79wOk86gSxkVec4KPTX69++5x68Yubn5/F+w52z7u08sJX7fZXv8ekT/d2mILJxq6sn+SC6qEJknzLJCxyZEKwWVqYmAPBxBE/9DLeZiWHu7lcr/VytrCRuHojncNuTt9h46tmacmYisnSamdN2bZptcsmSysdVsy1PrOvOzF3xN64Rb937t/og9KHxYdcjIUqFAmIAHGHNzlns+RTPgeUYAQm9DwpNxfxbhhBHPaw3/gfTcXO2L+eJVIx5nsyGkvm9X4/f+bGkH45G0PaSjcMXTjcZyTvi3UdHoCDjQd3IDUVsgwYmUoJK/gp4JJxeRI0MKHZIkgynyIBqBTOUs6rOVCojvjZ4mCQz49ZMlMcp8QoYk6NoBfsxnJtsBohpa8iGJS+ZH7gU7NxME6cmF+t7cO9vB8d3jTWSct0ycW9ranXmolNDwmVkNnxe+8JtoztwS5rKJ0xWS95tQ/1zMYzg69MzUZnNtl1ofNbsml/OJm6f9wjRjpnu2o4MzHzn77IQkRd+1DjwMQ2pqSjGMMhyjrgTbBAKksuUm0iU7hI0aN2wOKOq7WYBSH0HGihj/jkiPxAfmwsEbfYrjMG+j3ij932Db/LV7I/xruNrhnroxjR9HRMb2nTvO0ZXOoHPk8H2ZhDPx93qcE/53sH5np/dkIP7zzhTVKdR/BAY/9ElkkR+A6lJGsqpJ4oQcTxpvBT3Kn58VkaJjgHyPEIws57xkaHh9KuVpDEpJZeMbZ5w/zBHi5NMQ4r5VphsFqID7TyB9eR4pX216c3AHxpdAwoqU9qg0ZJ6yVLKmMSz1iG2z27ifx18NkY0LPx1W/wCc2l5LrznrIsiKsqbmB78A9wIGx4tI8rjihVHJyY9pgMirenVq0yWg7Iw7eogG7ZgYM3qR9959A/fZkg6MnD/exlkmc+jWV4SB15XUR+eqC6l6ZmgPtN9z5JMfik05OV8ljylunJ4J+wA/FUaQSSKotsYsCWqaPBidBLcxkWx7XKFRIb45TGaEhjlF9uUVPqXOtcIwsXbBvfoZXIyRYFdkfnqjExH98xpnPczqzjX/uNdO1Y17Wpi5+6Ts8BXtjVFasp9KZ1mOiNbH65c5w6HgmyF2jFCZywM8mWjRc7T5Pmt0lRy7Y71+jYbpGyvwG4sH0XeJxjYGRgYADiwBB/53h+m68M3MwvgCIM1z5N/g6j///9v5H5BbMnkMvBwAQSBQCIcA9gAHicY2BkYGAO+p8FJF/8//v/F/MLBqAICuAFALYQB5kAeJxjfsHAwLwAiCNB+P9fbJjJmoGBMRUo/wKCAfO2EnQAAAAAANoBXgGcAgICVALaA1IDvAPkBAYEPARyAAEAAAANAF0ABAAAAAAAAgAUACQAcwAAAG4LcAAAAAB4nHWRzWrCQBSFT+pPqUIXLXTTzayKUohGKIibCoLuhbrrYtTRxCYZmYyKyz5Fd32HvlDfoO/QkziIFJtw9bvnnpl7ZwLgBt/wcHieGAf2UGd24Atcou+4RH3kuEweO66QXx1XyaHjGh6ROa7jFp/cwStfMVvhy7GHO+/e8QWuvcBxifqz4zL5xXGF/Oa4Sn53XMPE+3Bcx4P3M9DrvYmWoRWNQVN02kFXTPdCU4pSGQu5saE2meiLhU6timPtz3SSs9ypTCdqrJabWJoT5QQnymSRTkXgt0/UkUqVkVbN807ZdtmxdiEWRidi6HqItdErNbN+aO2612qd9sYAGmvsYRBhyUu0EGhQbfK/gzYCdElTOgSdB1eEFBIxFYkNV4RFJWPeZyyYpVQVHTHZx4y/yVGX2LGWFZri51TccUOn5B7nPefVCSPvGhVVwUl9znveO2KkhV8Wk82PZ8qwZf8OVcu1+fSmWCMw/HMOwXvKaysqM+p+cVuWag8tvv+c+xdd+4+teJxtjUEOwiAURJla24KliQfhUA2g/Sl+CKXx+loNrpzVezOLEY34Ron/0WhwQoszOvQYIKFwwQiNSbSBeO2SZ0tBP4j3zVjKNng32ZmtD1VVXCuOiw/pJ8S3WOU6l+K5UOTaDC4+2TjKMtN9KQf1ezLx/Sg/00FCvABHhjDjAAB4nGPw3sFwIihiIyNjX+QGxp0cDBwMyQUbGVidNjEwMmiBGJu5mBg5ICw+BjCLzWkX0wGgNCeQze60i8EBwmZmcNmowtgRGLHBoSNiI3OKy0Y1EG8XRwMDI4tDR3JIBEhJJBBs5mFi5NHawfi/dQNL70YmBhcADHYj9AAA) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><style>/*github*/
.codehilite {background-color:#fff;color:#333333;}
.codehilite .hll {background-color:#ffffcc;}
.codehilite .c{color:#999988;font-style:italic}
.codehilite .err{color:#a61717;background-color:#e3d2d2}
.codehilite .k{font-weight:bold}
.codehilite .o{font-weight:bold}
.codehilite .cm{color:#999988;font-style:italic}
.codehilite .cp{color:#999999;font-weight:bold}
.codehilite .c1{color:#999988;font-style:italic}
.codehilite .cs{color:#999999;font-weight:bold;font-style:italic}
.codehilite .gd{color:#000000;background-color:#ffdddd}
.codehilite .ge{font-style:italic}
.codehilite .gr{color:#aa0000}
.codehilite .gh{color:#999999}
.codehilite .gi{color:#000000;background-color:#ddffdd}
.codehilite .go{color:#888888}
.codehilite .gp{color:#555555}
.codehilite .gs{font-weight:bold}
.codehilite .gu{color:#800080;font-weight:bold}
.codehilite .gt{color:#aa0000}
.codehilite .kc{font-weight:bold}
.codehilite .kd{font-weight:bold}
.codehilite .kn{font-weight:bold}
.codehilite .kp{font-weight:bold}
.codehilite .kr{font-weight:bold}
.codehilite .kt{color:#445588;font-weight:bold}
.codehilite .m{color:#009999}
.codehilite .s{color:#dd1144}
.codehilite .n{color:#333333}
.codehilite .na{color:teal}
.codehilite .nb{color:#0086b3}
.codehilite .nc{color:#445588;font-weight:bold}
.codehilite .no{color:teal}
.codehilite .ni{color:purple}
.codehilite .ne{color:#990000;font-weight:bold}
.codehilite .nf{color:#990000;font-weight:bold}
.codehilite .nn{color:#555555}
.codehilite .nt{color:navy}
.codehilite .nv{color:teal}
.codehilite .ow{font-weight:bold}
.codehilite .w{color:#bbbbbb}
.codehilite .mf{color:#009999}
.codehilite .mh{color:#009999}
.codehilite .mi{color:#009999}
.codehilite .mo{color:#009999}
.codehilite .sb{color:#dd1144}
.codehilite .sc{color:#dd1144}
.codehilite .sd{color:#dd1144}
.codehilite .s2{color:#dd1144}
.codehilite .se{color:#dd1144}
.codehilite .sh{color:#dd1144}
.codehilite .si{color:#dd1144}
.codehilite .sx{color:#dd1144}
.codehilite .sr{color:#009926}
.codehilite .s1{color:#dd1144}
.codehilite .ss{color:#990073}
.codehilite .bp{color:#999999}
.codehilite .vc{color:teal}
.codehilite .vg{color:teal}
.codehilite .vi{color:teal}
.codehilite .il{color:#009999}
.codehilite .gc{color:#999;background-color:#EAF2F5}
</style><title>Java</title></head><body><article class="markdown-body"><h1 id="1java">1、java基础<a class="headerlink" href="#1java" title="Permanent link"></a></h1>
<h2 id="11">1.1 基本数据类型<a class="headerlink" href="#11" title="Permanent link"></a></h2>
<h3 id="111">1.1.1 内置数据类型<a class="headerlink" href="#111" title="Permanent link"></a></h3>
<p>数据类型的取值范围都以常量的形式存储在了对应的包装类中。</p>
<p>数据类型.SIZE：二进制位数；数据类型.MIN_VALUE/MAX_VALUE。</p>
<p>如Integer.SIZE</p>
<ul>
<li>byte、Byte类</li>
</ul>
<p>8bits，有符号，以二进制补码表示的整数</p>
<p>-128到127</p>
<p>默认0</p>
<ul>
<li>short、Short类</li>
</ul>
<p>16bits,有符号，二进制补码表示</p>
<p>-2^15到2^15-1</p>
<p>默认0</p>
<ul>
<li>int、Integer类</li>
</ul>
<p>32bits，有符号，二进制补码表示</p>
<p>默认0</p>
<ul>
<li>long、Long类</li>
</ul>
<p>64bits，有符号，二进制补码表示</p>
<p>默认0L</p>
<p><strong>要在数值后面加上L，否则会作为整形解析，导致溢出</strong></p>
<ul>
<li>float、Float类</li>
</ul>
<p>32bits，浮点数存储</p>
<p>默认0.0f</p>
<p>不能用来表示精确的值，如货币</p>
<ul>
<li>double、Double类</li>
</ul>
<p>64bits，浮点数存储</p>
<p>默认0.0d</p>
<p>不能用来表示精确的值，如货币</p>
<ul>
<li>boolean</li>
</ul>
<p>1bit</p>
<p>true或着false</p>
<p>默认false</p>
<ul>
<li>char、Character类</li>
</ul>
<p><strong>16bits</strong>unicode字符</p>
<p>最小\u0000，最大\uffff，<strong>16进制</strong>表示。</p>
<p>char数据类型可以存储任何字符。</p>
<p>eg.  char letter = &ldquo;A&rdquo;; </p>
<h3 id="112">1.1.2 引用类型<a class="headerlink" href="#112" title="Permanent link"></a></h3>
<p>对象和数组都是引用数据类型，默认null。</p>
<p>eg.  Site site = new Site(&ldquo;Runoob&rdquo;);</p>
<h3 id="113">1.1.3 常量<a class="headerlink" href="#113" title="Permanent link"></a></h3>
<p>final修饰，声明后无法更改。</p>
<div class="codehilite"><pre><span class="kd">final</span> <span class="kt">double</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">3.1415926</span>
</pre></div>

<p>字符串常量和字符常量都可以包含任何Unicode字符。</p>
<p>eg.   </p>
<div class="codehilite"><pre><span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">&#39;\u0001&#39;</span><span class="o">;</span> <span class="c1">// 16进制Unicode字符</span>
<span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">&quot;\u0001&quot;</span><span class="o">;</span>
</pre></div>

<h2 id="12">1.2 变量类型<a class="headerlink" href="#12" title="Permanent link"></a></h2>
<h3 id="121">1.2.1 类变量（静态变量）<a class="headerlink" href="#121" title="Permanent link"></a></h3>
<p>独立于方法之外的变量，用static修饰。如 static int allClicks = 0</p>
<p>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。（和CPP相同）</p>
<p>静态变量属于类，在第一次被访问时创建，在程序结束时销毁。</p>
<h3 id="122">1.2.2 实例变量<a class="headerlink" href="#122" title="Permanent link"></a></h3>
<p>独立于方法之外的变量，没有static修饰。如String str = &ldquo;hello world&rdquo;</p>
<p>实例变量属于类的对象，在对象创建时创建，在对象销毁时销毁。</p>
<h3 id="123">1.2.3 局部变量<a class="headerlink" href="#123" title="Permanent link"></a></h3>
<p>类的方法中的变量，在栈上分配。</p>
<p>方法进入时创建，方法结束时销毁。</p>
<h2 id="13">1.3 修饰符<a class="headerlink" href="#13" title="Permanent link"></a></h2>
<h3 id="131">1.3.1 访问控制修饰符<a class="headerlink" href="#131" title="Permanent link"></a></h3>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同一包内</th>
<th>子孙类(同一包)</th>
<th>子孙类(不同包)</th>
<th>其他包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>protected</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y/N</td>
<td>N</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>private</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
<p>说明：关于protected的Y/N，子类与基类不在同一个包内时，子类实例可以访问其从基类继承而来的protected方法，但是不能访问基类实例的protected方法。</p>
<h3 id="132-abstract">1.3.2 abstract修饰符<a class="headerlink" href="#132-abstract" title="Permanent link"></a></h3>
<ul>
<li>抽象类</li>
</ul>
<p>抽象类，不能用来实例化对象， 声明抽象类的唯一目的时为了将来对该类进行扩充,具体实现由子类提供。<strong>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</strong></p>
<p>如果一个类包含抽象方法，那么一定要声明为抽象类。</p>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Caravan</span><span class="o">{</span>
  <span class="kd">private</span> <span class="kt">double</span> <span class="n">price</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">String</span> <span class="n">model</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">String</span> <span class="n">year</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">goFast</span><span class="o">();</span><span class="c1">//抽象方法</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">changeColor</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">C</span> <span class="kd">extends</span> <span class="n">Caravan</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">goFast</span><span class="o">();</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">changeColor</span><span class="o">();</span>
<span class="o">}</span> 
</pre></div>

<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认的方法实现</td>
<td>它可以有默认的方法实现</td>
<td>接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有public、protected和default这些修饰符</td>
<td>接口方法默认修饰符是public。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有main方法并且我们可以运行它</td>
<td>接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>多继承 抽象方法可以继承一个类和实现多个接口</td>
<td>接口只可以继承一个或多个其它接口</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>速度</td>
<td>它比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<ul>
<li>抽象方法</li>
</ul>
<p>抽象方法具体实现在子类中。在父类中，抽象方法只包含一个方法名，没有方法体。</p>
<p>子类必须重写父类的抽象方法，或者声明自身为<strong>抽象类</strong>。</p>
<h3 id="133-synchronized">1.3.3 synchronized修饰符<a class="headerlink" href="#133-synchronized" title="Permanent link"></a></h3>
<p>synchronized关键字声明的方法同一时间只能被<strong>同一个线程</strong>访问。</p>
<div class="codehilite"><pre>public synchronized void showDetails(){

}
</pre></div>

<h3 id="134-transient">1.3.4 transient修饰符<a class="headerlink" href="#134-transient" title="Permanent link"></a></h3>
<p>序列化的对象包含被transient修饰的实例变量时，java虚拟机（JVM）跳过该特定的变量。</p>
<p>作用：在序列化时，有的属性需要序列化，有的不需要序列化。比如一个用户的敏感信息（密码、银行卡号等），不希望在网络操作中被传输，则可以加上transient。这个字段的生命周期仅存于调用者的内存中而不会写到磁盘中持久化。</p>
<h3 id="135-volatile">1.3.5 volatile修饰符<a class="headerlink" href="#135-volatile" title="Permanent link"></a></h3>
<p>每次线程访问时，都强制从共享内存中重新读取改成员变量的值。当成员变量发生变化时，会强制线程将变化值写回共享内存。</p>
<h2 id="14">1.4 运算符<a class="headerlink" href="#14" title="Permanent link"></a></h2>
<h3 id="141">1.4.1 &gt;&gt;&gt;和&gt;&gt;<a class="headerlink" href="#141" title="Permanent link"></a></h3>
<p>>>：表示有符号右移，正数右移高位补0,负数右移高位补1。</p>
<p>>>>：表示无符号右移，负数和正数，高位通通补0。</p>
<h3 id="142">1.4.2 条件运算符<a class="headerlink" href="#142" title="Permanent link"></a></h3>
<p>?:和C一样。</p>
<h3 id="143-instanceof">1.4.3 instanceof<a class="headerlink" href="#143-instanceof" title="Permanent link"></a></h3>
<p>检查对象是否是一个特定类型（类类型和接口类型）</p>
<div class="codehilite"><pre><span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;James&quot;</span><span class="o">;</span>
<span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="n">name</span> <span class="k">instanceof</span> <span class="n">String</span><span class="o">;</span><span class="c1">//检查name是否时String类型</span>
</pre></div>

<p>说明：如果Car继承了Vehicle，用Car建立一个对象car，则car既是Car又是Vehicle。</p>
<h2 id="15">1.5 循环<a class="headerlink" href="#15" title="Permanent link"></a></h2>
<ul>
<li>
<p>while(){}</p>
</li>
<li>
<p>do{}while()</p>
</li>
<li>
<p>for(;;)</p>
</li>
<li>
<p>增强for(声明语句:表达式){}</p>
</li>
</ul>
<p>主要用于数组遍历。</p>
<div class="codehilite"><pre><span class="n">String</span> <span class="n">names</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;James&quot;</span><span class="o">,</span><span class="s">&quot;Larry&quot;</span><span class="o">,</span><span class="s">&quot;Tom&quot;</span><span class="o">,</span><span class="s">&quot;Lacy&quot;</span><span class="o">};</span>
<span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">:</span><span class="n">names</span><span class="o">)[</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">);</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>

<ul>
<li>continue</li>
</ul>
<p>直接进行下一次循环。</p>
<h2 id="16">1.6 分支结构<a class="headerlink" href="#16" title="Permanent link"></a></h2>
<ul>
<li>if &hellip; else if &hellip; else&hellip;</li>
</ul>
<p>和CPP相同。</p>
<ul>
<li>switch() case value :&hellip;break;default&hellip;break;</li>
</ul>
<p>和CPP相同。</p>
<p>支持String类型。</p>
<h2 id="17-numbercharstringmath">1.7 Number、Char、String和Math类<a class="headerlink" href="#17-numbercharstringmath" title="Permanent link"></a></h2>
<h3 id="171-number">1.7.1 Number类<a class="headerlink" href="#171-number" title="Permanent link"></a></h3>
<p>Integer、Long、Byte、Double、Float、Short</p>
<p>xxxValue()：将Number对象转化为xxx数据类型并返回。</p>
<p>compareTo()：将Number对象与参数比较。</p>
<p>equals()：判断number对象是否与参数相等。</p>
<p>valueOf()：返回一个Number对象指定的内置数据类型。</p>
<div class="codehilite"><pre>Integer X = Integer.valueOf(9);

Integer a = Integer.valueOf(&quot;444&quot;,16);//使用16进制,返回1092( = 0x444)
</pre></div>

<p>toString()：以字符串形式返回值。</p>
<p>parseInt()：将字符串解析为int类型。</p>
<blockquote>
<p>Integer i1 = 128;//装箱，相当于Integer.valueof(128);
int i = i1;//拆箱，相当于i1.intValue()</p>
</blockquote>
<h3 id="172-character">1.7.2 Character类<a class="headerlink" href="#172-character" title="Permanent link"></a></h3>
<p>isLetter()：是否是一个字母</p>
<p>isDigital()：是否是一个数字字符</p>
<p>isWhitespace()：是否是一个空格</p>
<p>isUpperCase()：是否是大写字母</p>
<p>isLowerCase()：是否是小谢字母</p>
<p>toUpperCase()：指定字母的大写形式</p>
<p>toLowerCase()：指定字母的小写形式</p>
<p>toString()：返回字符的字符串类型，长度1</p>
<h3 id="173-string">1.7.3 String类<a class="headerlink" href="#173-string" title="Permanent link"></a></h3>
<p><strong>不可改变</strong>，如果需要对字符串做多次修改，选择使用StringBuffer和StringBuilder类。</p>
<p>charAt(int index)：返回指定索引出的char值</p>
<p>compareTo(Object o 或者 String anotherString)：把这个字符串和另一个对象比较，等于返回0,大于返回小于0,小于返回大于0。</p>
<p>compareTo(String anotherString)：按字典顺序比较两个字符串。</p>
<p>&hellip;</p>
<h3 id="174-stringbufferstringbuilder">1.7.4 StringBuffer和StringBuilder类<a class="headerlink" href="#174-stringbufferstringbuilder" title="Permanent link"></a></h3>
<p>和String不同，可以被修改，并且不产生新的未使用对象。</p>
<p>StringBuilder：相比于StringBuffer，不是线程安全的，不能同步访问。但是StringBuilder具有速度优势。</p>
<p>StringBuffer append(String s)：将指定的字符串追加到字符序列。</p>
<p>StringBuffer reverse()：此字符序列用其反转形式取代。</p>
<p>delete(int start,int end)：移除此序列的子字符串中的字符。</p>
<p>insert(int offset,int i)：int参数的字符串表示形式插入此序列</p>
<p>replace(int start,int end,String str)：替换。</p>
<h3 id="175-math">1.7.5 Math类<a class="headerlink" href="#175-math" title="Permanent link"></a></h3>
<p>Math.sin()</p>
<p>Math.cos()</p>
<p>Math.tan()</p>
<p>Math.atan()</p>
<p>Math.toDegree()</p>
<p>Math.ceil()：返回大于等于给定参数的最小整数</p>
<p>Math.floor()：返回小于等于给定采纳数的最大整数</p>
<p>Math.rint()：返回与参数最接近的整数。返回类型为doule</p>
<p>Math.round()：四舍五入</p>
<p>Math.random()：返回随机数0.0到1.0</p>
<h2 id="18">1.8 数组<a class="headerlink" href="#18" title="Permanent link"></a></h2>
<ul>
<li>创建</li>
</ul>
<div class="codehilite"><pre>dataType[] arrayRefVar;//首选方法
dataType arrayRefVar[];//效果相同，但不是首选方法

dataType[] arrayRefVar = new dataType[arraySize];//第一步，使用dataType[arraySize]创建一个数组；第二步，把新创建的数组的引用复制给变量arrayRefVar
</pre></div>

<ul>
<li>foreach循环</li>
</ul>
<div class="codehilite"><pre>for(dataType element : arrayRefVar){}
</pre></div>

<ul>
<li>多维数组</li>
</ul>
<div class="codehilite"><pre>int a[][] = new int[2][3];
</pre></div>

<p>多维数组的动态初始化</p>
<div class="codehilite"><pre>String s[][] = new String[2][];
s[0] = new String[2];//这里确定每一行的元素个数
s[1] = new String[3];
s[0][0] = new String(&quot;Good&quot;);
s[0][1] = new String(&quot;Luck&quot;);
s[1][0] = new String(&quot;to&quot;);
s[1][1] = new String(&quot;you&quot;);
s[1][2] = new String(&quot;!&quot;);
</pre></div>

<ul>
<li>Array类</li>
</ul>
<p>java.util.Arrays类能方便地操作数组，提供的方法都是static静态的。</p>
<p>binarySearch(Object[] a,Object key)：二分查找法在给定数组中搜索给定值的对象。数组在调用前，必须排序好。如果查找值包含在数组中，则返回搜索键的索引，否则返回-1或者-“插入点”，插入点表示第一个大于该键key的元素索引。</p>
<p>equal(Object[] a,Object[] b)：是否相等</p>
<p>fill(Object[] a,int fromIndex,int toIndex,Object val,)：将val插入到指定范围中。</p>
<p>sort(Object[] a)：升序排列。</p>
<h2 id="19">1.9 时间<a class="headerlink" href="#19" title="Permanent link"></a></h2>
<h3 id="191-date">1.9.1 Date时间创建<a class="headerlink" href="#191-date" title="Permanent link"></a></h3>
<div class="codehilite"><pre><span class="n">Date</span><span class="o">(</span><span class="kt">int</span> <span class="n">year</span><span class="o">,</span><span class="kt">int</span> <span class="n">month</span><span class="o">,</span><span class="kt">int</span> <span class="n">date</span><span class="o">);</span><span class="c1">//以int型表示年月日</span>

<span class="n">Date</span><span class="o">(</span><span class="kt">int</span> <span class="n">year</span><span class="o">,</span><span class="kt">int</span> <span class="n">month</span><span class="o">,</span><span class="kt">int</span> <span class="n">date</span><span class="o">,</span><span class="kt">int</span> <span class="n">hour</span><span class="o">,</span><span class="kt">int</span> <span class="n">min</span><span class="o">);</span>

<span class="n">Date</span><span class="o">(</span><span class="kt">int</span> <span class="n">year</span><span class="o">,</span><span class="kt">int</span> <span class="n">month</span><span class="o">,</span><span class="kt">int</span> <span class="n">date</span><span class="o">,</span><span class="kt">int</span> <span class="n">hour</span><span class="o">,</span><span class="kt">int</span> <span class="n">min</span><span class="o">,</span><span class="kt">int</span> <span class="n">sec</span><span class="o">);</span>
</pre></div>

<h3 id="192">1.9.2 方法<a class="headerlink" href="#192" title="Permanent link"></a></h3>
<ul>
<li>get时间</li>
</ul>
<div class="codehilite"><pre><span class="c1">//格林尼治时间</span>
<span class="n">Date</span><span class="o">(</span><span class="kt">long</span> <span class="n">date</span><span class="o">);</span><span class="c1">//date:距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数</span>

<span class="o">.</span><span class="na">getYear</span><span class="o">()</span><span class="err">、</span><span class="o">.</span><span class="na">getHour</span><span class="o">()</span><span class="err">、</span><span class="o">.</span><span class="na">getMonth</span><span class="o">()</span><span class="err">、</span><span class="o">.</span><span class="na">getMinutes</span><span class="o">()</span><span class="err">、</span><span class="o">.</span><span class="na">getSecond</span><span class="o">()</span>


<span class="n">getTime</span><span class="o">()</span><span class="err">：</span><span class="n">返回子格林尼治时间</span>
</pre></div>

<ul>
<li>比较时间</li>
</ul>
<p>三个方法：</p>
<p>1、getTime后比较</p>
<p>2、before()、after()、equals()来比较</p>
<p>3、compareTo()：由Comparable接口定义，Date类实现了这个接口。</p>
<ul>
<li>格式化时间</li>
</ul>
<p>SimpleDateFormat ft = new SimpleDateFormat(&ldquo;E yyyy.MM.dd &lsquo;at&rsquo; hh:mm:ss a zzz&rdquo;);</p>
<p>E：星期；y：四位年份；M：月份；d：一个月的日期； &lsquo;at&rsquo;：显示at；h：小时；m：分钟；s：秒；a：AM；z：时区。</p>
<p>S：毫秒。</p>
<p>可以格式化输出，通过System.out.printf(&ldquo;%tc%n&rdquo;)。以%t开头。c：全部日期和时间信息，F：年-月-日&hellip;</p>
<ul>
<li>解析字符串</li>
</ul>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.text.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DateDemo</span> <span class="o">{</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
      <span class="n">SimpleDateFormat</span> <span class="n">ft</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleDateFormat</span> <span class="o">(</span><span class="s">&quot;yyyy-MM-dd&quot;</span><span class="o">);</span> 

      <span class="n">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;1818-11-11&quot;</span> <span class="o">:</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> 

      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">input</span> <span class="o">+</span> <span class="s">&quot; Parses as &quot;</span><span class="o">);</span> 

      <span class="n">Date</span> <span class="n">t</span><span class="o">;</span> 

      <span class="k">try</span> <span class="o">{</span> 
          <span class="n">t</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">input</span><span class="o">);</span> <span class="c1">//解析字符串</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span> 
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ParseException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> 
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Unparseable using &quot;</span> <span class="o">+</span> <span class="n">ft</span><span class="o">);</span> 
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3 id="193-sleep">1.9.3 休眠sleep<a class="headerlink" href="#193-sleep" title="Permanent link"></a></h3>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SleepDemo</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span> 
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">Date</span><span class="o">(</span> <span class="o">)</span> <span class="o">+</span> <span class="s">&quot;\n&quot;</span><span class="o">);</span> 
         <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">*</span><span class="mi">3</span><span class="o">);</span>   <span class="c1">// 休眠3秒</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">Date</span><span class="o">(</span> <span class="o">)</span> <span class="o">+</span> <span class="s">&quot;\n&quot;</span><span class="o">);</span> 
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> 
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Got an exception!&quot;</span><span class="o">);</span> 
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3 id="194">1.9.4 测量时间<a class="headerlink" href="#194" title="Permanent link"></a></h3>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DiffDemo</span> <span class="o">{</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
         <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">(</span> <span class="o">);</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">Date</span><span class="o">(</span> <span class="o">)</span> <span class="o">+</span> <span class="s">&quot;\n&quot;</span><span class="o">);</span>
         <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">10</span><span class="o">);</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="n">Date</span><span class="o">(</span> <span class="o">)</span> <span class="o">+</span> <span class="s">&quot;\n&quot;</span><span class="o">);</span>
         <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">(</span> <span class="o">);</span>
         <span class="kt">long</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Difference is : &quot;</span> <span class="o">+</span> <span class="n">diff</span><span class="o">);</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Got an exception!&quot;</span><span class="o">);</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3 id="195-calender">1.9.5 Calender 类<a class="headerlink" href="#195-calender" title="Permanent link"></a></h3>
<p>设置和获取日期数据的特定部分，比如小时、日、分钟，或者在日期的这些部分加上或者减去值。</p>
<p>具体见菜鸟教程。</p>
<h2 id="110">1.10 正则表达式<a class="headerlink" href="#110" title="Permanent link"></a></h2>
<h3 id="1101">1.10.1 类和方法<a class="headerlink" href="#1101" title="Permanent link"></a></h3>
<p>java.util.regex包主要包括三个类：</p>
<ul>
<li>Pattern类</li>
</ul>
<p>Pattern对象是一个正则表达式的编译表示。没有公共构造方法，要创建一个Pattern对象，必须首先调用其公共静态编译方法。</p>
<ul>
<li>Matcher类</li>
</ul>
<p>Matcher对象是对输入字符串进行解释和匹配操作的引擎。没有公共构造方法，要调用Pattern对象的matcher方法来获得一个Matcher对象。</p>
<ul>
<li>PatternSyntaxException</li>
</ul>
<p>表示一个正则表达式模式中的语法错误。</p>
<p>使用方法：</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.regex.Matcher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.regex.Pattern</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegexMatches</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span> <span class="n">String</span> <span class="n">args</span><span class="o">[]</span> <span class="o">){</span>

      <span class="c1">// 按指定模式在字符串查找</span>
      <span class="n">String</span> <span class="n">line</span> <span class="o">=</span> <span class="s">&quot;This order was placed for QT3000! OK?&quot;</span><span class="o">;</span>
      <span class="n">String</span> <span class="n">pattern</span> <span class="o">=</span> <span class="s">&quot;(\\D*)(\\d+)(.*)&quot;</span><span class="o">;</span>

      <span class="c1">// 创建 Pattern 对象</span>
      <span class="n">Pattern</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="n">pattern</span><span class="o">);</span>

      <span class="c1">// 现在创建 matcher 对象</span>
      <span class="n">Matcher</span> <span class="n">m</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">find</span><span class="o">(</span> <span class="o">))</span> <span class="o">{</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Found value: &quot;</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">);</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Found value: &quot;</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">);</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Found value: &quot;</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">);</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Found value: &quot;</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span> <span class="o">);</span> 
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;NO MATCH&quot;</span><span class="o">);</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3 id="1102">1.10.2 正则表达式语法<a class="headerlink" href="#1102" title="Permanent link"></a></h3>
<p>\\：插入一个正则表达式的反斜线，其后的字符具有特殊意义。即\\d表示\d。</p>
<p>具体将菜鸟教程。</p>
<h2 id="111_1">1.11 可变参数<a class="headerlink" href="#111_1" title="Permanent link"></a></h2>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">printMax</span><span class="o">(</span><span class="kt">double</span><span class="o">...</span> <span class="n">numbers</span><span class="o">){</span>  <span class="c1">//可输入多个参数</span>
  <span class="k">if</span><span class="o">(</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>   
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;No argument passed&quot;</span><span class="o">);</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">result</span><span class="o">){</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;The max value is &quot;</span><span class="o">+</span><span class="n">result</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>

<h2 id="112-finalize">1.12 finalize()方法<a class="headerlink" href="#112-finalize" title="Permanent link"></a></h2>
<p>清除回收对象。</p>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FinalizationDemo</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Cake</span> <span class="n">c1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cake</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">Cake</span> <span class="n">c2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cake</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="n">Cake</span> <span class="n">c3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cake</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

    <span class="n">c2</span> <span class="o">=</span> <span class="n">c3</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span> <span class="c1">//调用Java垃圾收集器</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Cake</span> <span class="kd">extends</span> <span class="n">Object</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">Cake</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Cake Object &quot;</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">&quot;is created&quot;</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Throwable</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">finalize</span><span class="o">();</span><span class="c1">//调用父类的finalize</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Cake Object &quot;</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">&quot;is disposed&quot;</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h2 id="113-javastreamfileio">1.13 Java流(Stream)、文件(File)和IO<a class="headerlink" href="#113-javastreamfileio" title="Permanent link"></a></h2>
<h3 id="1131">1.13.1 读取控制台输入<a class="headerlink" href="#1131" title="Permanent link"></a></h3>
<p><strong>BufferReader</strong>
为获得一个绑定到控制台的字符流，将System.in包装在一个BufferedReader对象中来创建一个字符流。</p>
<div class="codehilite"><pre><span class="n">BufferReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
</pre></div>

<p>后面用read()方法从控制台读取一个字符，用readLine()方法读取一个字符串。</p>
<ul>
<li>读取字符</li>
</ul>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BRRead</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">c</span><span class="o">;</span>
        <span class="c1">// 使用 System.in 创建 BufferedReader</span>
        <span class="n">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;输入字符, 按下 &#39;q&#39; 键退出。&quot;</span><span class="o">);</span>
        <span class="c1">// 读取字符</span>
        <span class="k">do</span> <span class="o">{</span>
            <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="n">br</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">c</span> <span class="o">!=</span> <span class="sc">&#39;q&#39;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>输出：</p>
<div class="codehilite"><pre>输入字符, 按下 &#39;q&#39; 键退出。
runoob
r
u
n
o
o
b


q
q
</pre></div>

<ul>
<li>读字符串</li>
</ul>
<div class="codehilite"><pre><span class="c1">//使用 BufferedReader 在控制台读取字符</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BRReadLines</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>   <span class="c1">//抛出IOException</span>
        <span class="c1">// 使用 System.in 创建 BufferedReader</span>
        <span class="n">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="n">String</span> <span class="n">str</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Enter lines of text.&quot;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Enter &#39;end&#39; to quit.&quot;</span><span class="o">);</span>
        <span class="k">do</span> <span class="o">{</span>
            <span class="n">str</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">str</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&quot;end&quot;</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>输出：</p>
<div class="codehilite"><pre>Enter lines of text.
Enter &#39;end&#39; to quit.
This is line one
This is line one
This is line two
This is line two
end
end
</pre></div>

<p><strong>Scanner</strong>
hasNext()和hasNextLine()来判断是否还有输入数据</p>
<p>next()和nextLine()方法获取输入的字符串。</p>
<div class="codehilite"><pre>Scanner s = new Scanner(System.in);
</pre></div>

<ul>
<li>next和nextLine的区别</li>
</ul>
<p>1、next一定要读取到有效字符后才可以结束输入</p>
<p>2、对输入有效字符之前遇到的空白，next会自动将其去掉</p>
<p>3、只有有效字符后才将后面输入的空白作为分隔符或者结束符</p>
<p>4、next不能得到带有空格的字符串</p>
<p>5、nextLine以Enter为结束符，返回输入回车之前的所有字符</p>
<ul>
<li>输入int或者float等</li>
</ul>
<p>先hasNextXxx()方法进行验证，在使用nextXxx()来读取（Xxx表示Int或者Float）。</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">ScannerDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Scanner</span> <span class="n">scan</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>

        <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">scan</span><span class="o">.</span><span class="na">hasNextDouble</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">scan</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">();</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">x</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m</span> <span class="o">+</span> <span class="s">&quot;个数的和为&quot;</span> <span class="o">+</span> <span class="n">sum</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m</span> <span class="o">+</span> <span class="s">&quot;个数的平均值是&quot;</span> <span class="o">+</span> <span class="o">(</span><span class="n">sum</span> <span class="o">/</span> <span class="n">m</span><span class="o">));</span>
        <span class="n">scan</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>输入输出：</p>
<div class="codehilite"><pre>12
23
15
21.4
end
4个数的和为71.4
4个数的平均值是17.85
</pre></div>

<p><strong>Console</strong></p>
<p>输入的时候字符都是可见的，所以Scanner类不适合从控制台读取密码。从Java SE 6开始特别引入了Console类来实现这个目的。若要读取一个密码，可以采用下面这段代码:</p>
<div class="codehilite"><pre><span class="n">Console</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">console</span><span class="o">();</span>
<span class="n">String</span> <span class="n">username</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="na">readline</span><span class="o">(</span><span class="s">&quot;User name: &quot;</span><span class="o">);</span>
<span class="kt">char</span><span class="o">[]</span> <span class="n">passwd</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="na">readPassword</span><span class="o">(</span><span class="s">&quot;Password: &quot;</span><span class="o">);</span>
</pre></div>

<h3 id="1132">1.13.2 读写文件<a class="headerlink" href="#1132" title="Permanent link"></a></h3>
<ul>
<li>FileInputStream</li>
</ul>
<p>该流从文件读取数据，可以用new来创建。</p>
<div class="codehilite"><pre><span class="n">FileInputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&quot;C:/java/hello&quot;</span><span class="o">);</span>
<span class="n">或者</span>
<span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&quot;C:/java/hello&quot;</span><span class="o">);</span><span class="c1">//使用文件对象来创建一个输入流对象</span>
<span class="n">FileInputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
</pre></div>

<ul>
<li>FileOutputStream
该流从文件读取数据，可以用new来创建。</li>
</ul>
<div class="codehilite"><pre>import java.io.*;

public class fileStreamTest {
    public static void main(String args[]) {
        try {
            byte bWrite[] = { 11, 21, 3, 40, 5 };
            OutputStream os = new FileOutputStream(&quot;test.txt&quot;);
            for (int x = 0; x &lt; bWrite.length; x++) {
                os.write(bWrite[x]); // writes the bytes
            }
            os.close();

            InputStream is = new FileInputStream(&quot;test.txt&quot;);
            int size = is.available();

            for (int i = 0; i &lt; size; i++) {
                System.out.print((char) is.read() + &quot;  &quot;);
            }
            is.close();
        } catch (IOException e) {
            System.out.print(&quot;Exception&quot;);
        }
    }
}
</pre></div>

<div class="codehilite"><pre>import java.io.*;

public class fileStreamTest2 {
    public static void main(String[] args) throws IOException {

        File f = new File(&quot;a.txt&quot;);
        FileOutputStream fop = new FileOutputStream(f);
        // 构建FileOutputStream对象,文件不存在会自动新建

        OutputStreamWriter writer = new OutputStreamWriter(fop, &quot;UTF-8&quot;);
        // 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk

        writer.append(&quot;中文输入&quot;);
        // 写入到缓冲区

        writer.append(&quot;\r\n&quot;);
        // 换行

        writer.append(&quot;English&quot;);
        // 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入

        writer.close();
        // 关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉

        fop.close();
        // 关闭输出流,释放系统资源

        FileInputStream fip = new FileInputStream(f);
        // 构建FileInputStream对象

        InputStreamReader reader = new InputStreamReader(fip, &quot;UTF-8&quot;);
        // 构建InputStreamReader对象,编码与写入相同

        StringBuffer sb = new StringBuffer();
        while (reader.ready()) {
            sb.append((char) reader.read());
            // 转成char加到StringBuffer对象中
        }
        System.out.println(sb.toString());
        reader.close();
        // 关闭读取流

        fip.close();
        // 关闭输入流,释放系统资源

    }
}
</pre></div>

<h2 id="114">1.14 异常处理<a class="headerlink" href="#114" title="Permanent link"></a></h2>
<h3 id="1141">1.14.1 异常发生原因分类<a class="headerlink" href="#1141" title="Permanent link"></a></h3>
<p>1、用户输入非法数据</p>
<p>2、要打开的文件不存在</p>
<p>3、网络通信时连接中断，或者JVM内存溢出</p>
<h3 id="1142-exception">1.14.2 Exception类的层次<a class="headerlink" href="#1142-exception" title="Permanent link"></a></h3>
<p>异常类都是java.lang.Exception类继承的子类。</p>
<p>Exception是Throwable类的子类，Throwable类还有子类Error。</p>
<p>Throwable</p>
<p>|</p>
<p>|-----Error</p>
<p>|</p>
<p>|-----Exception</p>
<p>Exception</p>
<p>|</p>
<p>|-----IOException</p>
<p>|</p>
<p>|-----RuntimeException</p>
<ul>
<li>内置异常类</li>
</ul>
<p>java定义了异常类在java.lang标准包中</p>
<p><strong>非检查性异常</strong></p>
<p>运行时出现的异常。比如溢出等。</p>
<div class="codehilite"><pre>ArithmeticException 当出现异常的运算条件时，抛出此异常。例如，一个整数&quot;除以零&quot;时，抛出此类的一个实例。
ArrayIndexOutOfBoundsException  用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。
ArrayStoreException 试图将错误类型的对象存储到一个对象数组时抛出的异常。
ClassCastException  当试图将对象强制转换为不是实例的子类时，抛出该异常。
IllegalArgumentException    抛出的异常表明向方法传递了一个不合法或不正确的参数。
IllegalMonitorStateException    抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。
IllegalStateException   在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。
IllegalThreadStateException 线程没有处于请求操作所要求的适当状态时抛出的异常。
IndexOutOfBoundsException   指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。
NegativeArraySizeException  如果应用程序试图创建大小为负的数组，则抛出该异常。
NullPointerException    当应用程序试图在需要对象的地方使用 null 时，抛出该异常
NumberFormatException   当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。
SecurityException   由安全管理器抛出的异常，指示存在安全侵犯。
StringIndexOutOfBoundsException 此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。
UnsupportedOperationException   当不支持请求的操作时，抛出该异常。
</pre></div>

<p><strong>检查性异常</strong></p>
<p>编译的时候的异常。例如打开一个不存在的文件，一个异常发生。</p>
<div class="codehilite"><pre>ClassNotFoundException  应用程序试图加载类时，找不到相应的类，抛出该异常。
CloneNotSupportedException  当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。
IllegalAccessException  拒绝访问一个类的时候，抛出该异常。
InstantiationException  当试图使用 Class 类中的 newInstance 创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。
InterruptedException    一个线程被另一个线程中断，抛出该异常。
NoSuchFieldException    请求的变量不存在
NoSuchMethodException   请求的方法不存在
</pre></div>

<p><strong>异常方法</strong></p>
<div class="codehilite"><pre>public String getMessage()    返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。
public Throwable getCause()    返回一个Throwable 对象代表异常原因。
public String toString()     使用getMessage()的结果返回类的串级名字。
public void printStackTrace()    打印toString()结果和栈层次到System.err，即错误输出流。
public StackTraceElement [] getStackTrace()   返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。
public Throwable fillInStackTrace()     用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。
</pre></div>

<p>实例：</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExcepTest</span><span class="o">{</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[]){</span>
      <span class="k">try</span><span class="o">{</span>
         <span class="kt">int</span> <span class="n">a</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Access element three :&quot;</span> <span class="o">+</span> <span class="n">a</span><span class="o">[</span><span class="mi">3</span><span class="o">]);</span>
      <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">ArrayIndexOutOfBoundsException</span> <span class="n">e</span><span class="o">){</span>    <span class="c1">//这里是定义一个要捕获的异常名，这里是ArrayIndexOutOfBoundsException</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Exception thrown  :&quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Out of the block&quot;</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>多重捕获块：</p>
<div class="codehilite"><pre><span class="k">try</span><span class="o">{</span>
   <span class="c1">// 程序代码</span>
<span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">异常类型1</span> <span class="n">异常的变量名1</span><span class="o">){</span>   <span class="c1">//如果异常，先抛给这个。如果不匹配，则抛给下一个。</span>
  <span class="c1">// 程序代码</span>
<span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">异常类型2</span> <span class="n">异常的变量名2</span><span class="o">){</span>
  <span class="c1">// 程序代码</span>
<span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">异常类型2</span> <span class="n">异常的变量名2</span><span class="o">){</span>
  <span class="c1">// 程序代码</span>
<span class="o">}</span>
</pre></div>

<h3 id="1143-throwsthrow">1.14.3 throws/throw关键字<a class="headerlink" href="#1143-throwsthrow" title="Permanent link"></a></h3>
<p>如果一个方法不处理检查性异常，而交给方法调用处进行处理，则该方法必须使用throws关键字来声明。可以抛出多个异常，用逗号隔开。throws表示这个方法有可能抛出的异常。</p>
<p>也可以用throw关键字抛出异常，无论它是新实例化的还是刚捕获到的。</p>
<p>区别：throws表示一个方法声明可能抛出一个异常，throw表示此处抛出一个自定义的异常（可以自定义，需要继承Exception，也可以是java自身给出的异常类）</p>
<div class="codehilite"><pre>import java.io.*;
public class className
{
  public void deposit(double amount) throws RemoteException,InsufficientFundsException    //异常交给
  {
    // Method implementation
    throw new RemoteException();//抛出异常
  }
  //Remainder of class definition
}
</pre></div>

<h3 id="1144-finally">1.14.4 finally关键字<a class="headerlink" href="#1144-finally" title="Permanent link"></a></h3>
<p>finally代码块中，可以运行清理类型等收尾善后性质的语句。</p>
<ul>
<li>
<p>使用案例
<div class="codehilite"><pre><span class="k">try</span><span class="o">{</span>
  <span class="c1">// 程序代码</span>
<span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">异常类型1</span> <span class="n">异常的变量名1</span><span class="o">){</span>
  <span class="c1">// 程序代码</span>
<span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">异常类型2</span> <span class="n">异常的变量名2</span><span class="o">){</span>
  <span class="c1">// 程序代码</span>
<span class="o">}</span><span class="k">finally</span><span class="o">{</span>
  <span class="c1">// 程序代码</span>
<span class="o">}</span>
</pre></div></p>
</li>
<li>
<p>特殊情况</p>
</li>
</ul>
<p><strong>这里会返回2,而不是1。因为finally总是比catch的return先执行。</strong></p>
<p><strong>catch 块中有退出系统的语句 System.exit(-1); finally就不会被执行</strong></p>
<div class="codehilite"><pre><span class="k">try</span><span class="o">{</span>
   <span class="c1">//待捕获代码    </span>
<span class="o">}</span><span class="k">catch</span><span class="err">（</span><span class="n">Exception</span> <span class="n">e</span><span class="err">）</span><span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;catch is begin&quot;</span><span class="o">);</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="err">；</span>
<span class="o">}</span><span class="k">finally</span><span class="o">{</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;finally is begin&quot;</span><span class="o">);</span>
     <span class="k">return</span> <span class="mi">2</span> <span class="o">;</span>
<span class="o">}</span>
</pre></div>

<h3 id="1145">1.14.5 声明自定义异常<a class="headerlink" href="#1145" title="Permanent link"></a></h3>
<ul>
<li>所有异常都是必须时Trowable的子类</li>
<li>如果希望写一个检查性异常类，则需要继承Exception类。</li>
<li>
<p>如果希望写一个运行时异常类，需要继承RuntimeException</p>
</li>
<li>
<p>自定义一个异常类</p>
</li>
</ul>
<p>CheckingAccount类中包含一个withdraw方法抛出一个insufficientFundsException</p>
<div class="codehilite"><pre><span class="c1">// 文件名称 CheckingAccount.java</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="c1">//此类模拟银行账户</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckingAccount</span>
<span class="o">{</span>
  <span class="c1">//balance为余额，number为卡号</span>
   <span class="kd">private</span> <span class="kt">double</span> <span class="n">balance</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kt">int</span> <span class="n">number</span><span class="o">;</span>
   <span class="kd">public</span> <span class="nf">CheckingAccount</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span>
   <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">;</span>
   <span class="o">}</span>
  <span class="c1">//方法：存钱</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deposit</span><span class="o">(</span><span class="kt">double</span> <span class="n">amount</span><span class="o">)</span>
   <span class="o">{</span>
      <span class="n">balance</span> <span class="o">+=</span> <span class="n">amount</span><span class="o">;</span>
   <span class="o">}</span>
  <span class="c1">//方法：取钱</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">withdraw</span><span class="o">(</span><span class="kt">double</span> <span class="n">amount</span><span class="o">)</span> <span class="kd">throws</span>
                              <span class="n">InsufficientFundsException</span>
   <span class="o">{</span>
      <span class="k">if</span><span class="o">(</span><span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">balance</span><span class="o">)</span>
      <span class="o">{</span>
         <span class="n">balance</span> <span class="o">-=</span> <span class="n">amount</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">else</span>
      <span class="o">{</span>
         <span class="kt">double</span> <span class="n">needs</span> <span class="o">=</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">balance</span><span class="o">;</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="n">InsufficientFundsException</span><span class="o">(</span><span class="n">needs</span><span class="o">);</span>
      <span class="o">}</span>
   <span class="o">}</span>
  <span class="c1">//方法：返回余额</span>
   <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getBalance</span><span class="o">()</span>
   <span class="o">{</span>
      <span class="k">return</span> <span class="n">balance</span><span class="o">;</span>
   <span class="o">}</span>
  <span class="c1">//方法：返回卡号</span>
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getNumber</span><span class="o">()</span>
   <span class="o">{</span>
      <span class="k">return</span> <span class="n">number</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//文件名称 BankDemo.java</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BankDemo</span>
<span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
   <span class="o">{</span>
      <span class="n">CheckingAccount</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CheckingAccount</span><span class="o">(</span><span class="mi">101</span><span class="o">);</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Depositing $500...&quot;</span><span class="o">);</span>
      <span class="n">c</span><span class="o">.</span><span class="na">deposit</span><span class="o">(</span><span class="mf">500.00</span><span class="o">);</span>
      <span class="k">try</span>
      <span class="o">{</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;\nWithdrawing $100...&quot;</span><span class="o">);</span>
         <span class="n">c</span><span class="o">.</span><span class="na">withdraw</span><span class="o">(</span><span class="mf">100.00</span><span class="o">);</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;\nWithdrawing $600...&quot;</span><span class="o">);</span>
         <span class="n">c</span><span class="o">.</span><span class="na">withdraw</span><span class="o">(</span><span class="mf">600.00</span><span class="o">);</span>
      <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">InsufficientFundsException</span> <span class="n">e</span><span class="o">)</span>
      <span class="o">{</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Sorry, but you are short $&quot;</span>
                                  <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getAmount</span><span class="o">());</span>
         <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<ul>
<li>实用案例</li>
</ul>
<div class="codehilite"><pre><span class="cm">/**</span>
<span class="cm"> * 异常:</span>
<span class="cm"> * finally不一定被执行，，例如 catch 块中有退出系统的语句 System.exit(-1); finally就不会被执行</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Demo</span> <span class="o">{</span>

    <span class="cm">/**</span>
<span class="cm">     * @param args</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//检查异常1.打开文件</span>
        <span class="n">FileReader</span> <span class="n">fr</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">fr</span><span class="o">=</span><span class="k">new</span> <span class="n">FileReader</span><span class="o">(</span><span class="s">&quot;d:\\aa.text&quot;</span><span class="o">);</span>
            <span class="c1">// 在出现异常的地方，下面的代码的就不执行</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;aaa&quot;</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;进入catch&quot;</span><span class="o">);</span>
            <span class="c1">// 文档读取异常</span>
            <span class="c1">// System.exit(-1);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;message=&quot;</span><span class="o">+</span><span class="n">e</span><span class="o">.</span><span class="na">getLocalizedMessage</span><span class="o">());</span>  <span class="c1">//没有报哪一行出错</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>   <span class="c1">// 打印出错异常还出现可以报出错先异常的行</span>
        <span class="o">}</span>
        <span class="c1">// 这个语句块不管发生没有发生异常，都会执行</span>
        <span class="c1">// 一般来说，把需要关闭的资源，文件，连接，内存等</span>
        <span class="k">finally</span>
        <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;进入finally&quot;</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">fr</span><span class="o">!=</span><span class="kc">null</span><span class="o">);</span>
            <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">fr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// TODO: handle exception</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;OK&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h2 id="1x">1.X 注释<a class="headerlink" href="#1x" title="Permanent link"></a></h2>
<div class="codehilite"><pre>/**
* Copyright (C), 2006-2010, ChengDu Lovo info. Co., Ltd.
* FileName: Test.java
* 类的详细说明
*
* @author 类创建者姓名
* @Date    创建日期
* @version 1.00
*/
</pre></div>

<div class="codehilite"><pre>/**
* 类方法的详细使用说明
*
* @param 参数1 参数1的使用说明
* @return 返回结果的说明
* @throws 异常类型.错误代码 注明从此类方法中抛出异常的说明
*/
</pre></div>

<div class="codehilite"><pre>/**
* 构造方法的详细使用说明
*
* @param 参数1 参数1的使用说明
* @throws 异常类型.错误代码 注明从此类方法中抛出异常的说明
*/
</pre></div>

<h1 id="2java">2、Java面向对象<a class="headerlink" href="#2java" title="Permanent link"></a></h1>
<h2 id="21">2.1 简单使用<a class="headerlink" href="#21" title="Permanent link"></a></h2>
<p>注：Java不支持多继承，即一个子类不能继承多个父类。但是可以支持多重继承，即A类继承B，B类继承C。</p>
<p>使用：</p>
<div class="codehilite"><pre><span class="c1">//公共父类</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span> 
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>  
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span> 
    <span class="kd">public</span> <span class="nf">Animal</span><span class="o">(</span><span class="n">String</span> <span class="n">myName</span><span class="o">,</span> <span class="kt">int</span> <span class="n">myid</span><span class="o">)</span> <span class="o">{</span> 
        <span class="n">name</span> <span class="o">=</span> <span class="n">myName</span><span class="o">;</span> 
        <span class="n">id</span> <span class="o">=</span> <span class="n">myid</span><span class="o">;</span>
    <span class="o">}</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">(){</span> 
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">+</span><span class="s">&quot;正在吃&quot;</span><span class="o">);</span> 
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sleep</span><span class="o">(){</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">+</span><span class="s">&quot;正在睡&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">introduction</span><span class="o">()</span> <span class="o">{</span> 
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;大家好！我是&quot;</span>         <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">&quot;号&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//企鹅类</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Penguin</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span>   <span class="c1">//extends继承</span>
    <span class="kd">public</span> <span class="nf">Penguin</span><span class="o">(</span><span class="n">String</span> <span class="n">myName</span><span class="o">,</span> <span class="kt">int</span> <span class="n">myid</span><span class="o">)</span> <span class="o">{</span> 
        <span class="kd">super</span><span class="o">(</span><span class="n">myName</span><span class="o">,</span> <span class="n">myid</span><span class="o">);</span> <span class="c1">//通过super来调用父类的方法来初始化</span>
    <span class="o">}</span> 
<span class="o">}</span>
</pre></div>

<h2 id="22">2.2 关键字<a class="headerlink" href="#22" title="Permanent link"></a></h2>
<h3 id="221-extends">2.2.1 extends关键字<a class="headerlink" href="#221-extends" title="Permanent link"></a></h3>
<p>只能继承一个父类。</p>
<h3 id="222-implements">2.2.2 implements关键字<a class="headerlink" href="#222-implements" title="Permanent link"></a></h3>
<p>implements关键字可以变相使java具有多继承的特性，适用范围为类继承接口的情况，可以同时继承多个接口。</p>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sleep</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">B</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="n">A</span><span class="o">,</span><span class="n">B</span> <span class="o">{</span>
<span class="o">}</span>
</pre></div>

<h3 id="223-final">2.2.3 final关键字<a class="headerlink" href="#223-final" title="Permanent link"></a></h3>
<p>在实例变量中也出现过final，表示该变量不能被修改。</p>
<p>在继承中，final修饰的class（类）不能被继承,同时类内的方法自动声明为final，但是类内的实例变量不是final。</p>
<div class="codehilite"><pre><span class="c1">//final声明类名</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="nc">类名</span><span class="o">{}</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//final声明方法</span>
<span class="n">修饰符</span><span class="o">(</span><span class="kd">public</span><span class="o">/</span><span class="kd">private</span><span class="o">/</span><span class="k">default</span><span class="o">/</span><span class="kd">protected</span><span class="o">)</span> <span class="kd">final</span> <span class="n">返回值类型</span> <span class="nf">方法名</span><span class="o">(){}</span>
</pre></div>

<p>final的总结：</p>
<p>final修饰属性或变量：不管是基本类型还是引用，其中的值不能变。引用类型变量里买内存放的是一个地址，所以用final修饰引用类型变量指的是它的地址不变，而地址中的数值可以改变。</p>
<p>final修饰类中的方法：方法可以被继承，但是无法重写。</p>
<p>final修饰类：类不可以被继承。</p>
<h2 id="23">2.3 构造器<a class="headerlink" href="#23" title="Permanent link"></a></h2>
<p>调用父类的构造方法的唯一途径是使用super关键字。</p>
<p>子类不能继承父类的构造器，如果父类的构造器<strong>带有参数</strong>，则<strong>必须</strong>在子类的构造其中显式通过super关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果没有参数并且子类的构造函数没有显式调用父类的含参构造方法，在编译的时候，会自动给子类的第一个语句放上super()。</p>
<div class="codehilite"><pre><span class="kd">class</span> <span class="nc">SuperClass</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
  <span class="n">SuperClass</span><span class="o">(){</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;SuperClass()&quot;</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="n">SuperClass</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;SuperClass(int n)&quot;</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SubClass</span> <span class="kd">extends</span> <span class="n">SuperClass</span><span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>

  <span class="n">SubClass</span><span class="o">(){</span>
    <span class="kd">super</span><span class="o">(</span><span class="mi">300</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;SubClass&quot;</span><span class="o">);</span>
  <span class="o">}</span>  

  <span class="kd">public</span> <span class="nf">SubClass</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;SubClass(int n):&quot;</span><span class="o">+</span><span class="n">n</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestSuperSub</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span> <span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[]){</span>
    <span class="n">SubClass</span> <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubClass</span><span class="o">();</span>
    <span class="n">SubClass</span> <span class="n">sc2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubClass</span><span class="o">(</span><span class="mi">200</span><span class="o">);</span> 
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>注意：</p>
<p>java文件被编译成class文件时，在子类的所有构造函数中的第一行（第一个语句）默认自动添加super()语句，在执行子类的构造函数之前，总是会先执行父类中的构造函数。</p>
<p>1、如果父类中不包含默认构造函数，那么子类中的super()语句 就会执行失败，系统就会报错。一般默认构造函数编译时会自动添加，但如果类中已经有了一个构造函数，就不会添加。</p>
<p>2、执行父类构造函数的语句只能放在函数内语句的首句，不然会报错。</p>
<p>在继承关系中，在调用函数（方法）或者类中的成员变量时，JVM（Java虚拟机）会先检测 当前类（子类）是否含有该函数或者成员变量，如果有就执行子类中的，如果咩有才会执行父类的。</p>
<h2 id="24-java">2.4 Java转型问题<a class="headerlink" href="#24-java" title="Permanent link"></a></h2>
<p>1、父类引用指向子类对象，而子类引用不能指向父类对象。</p>
<div class="codehilite"><pre>Father f1 = new Son();//向上转型，父类引用可以指向子类对象
Son s1 = (Son)f1;//向下转型，f1指向子类对象，s1指向f1即指向子类对象
</pre></div>

<p>但是f1不能调用Son中Father没有的方法。</p>
<div class="codehilite"><pre><span class="n">Father</span> <span class="n">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Father</span><span class="o">();</span>
<span class="n">Son</span> <span class="n">s2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Son</span><span class="o">)</span><span class="n">f2</span><span class="o">;</span><span class="c1">//错误，子类引用不能指向父类对象，</span>
</pre></div>

<h2 id="25-javaoverrideoverload">2.5 Java重写(Override)和重载(Overload)<a class="headerlink" href="#25-javaoverrideoverload" title="Permanent link"></a></h2>
<h3 id="251">2.5.1 重写<a class="headerlink" href="#251" title="Permanent link"></a></h3>
<p>1、子类对父类的允许访问的方法实现过程进行重新编写，返回值和形参都不能改变。即外壳不变，核心重写。</p>
<p>2、重写方法不能抛出新的检查异常或者比被重写方法更加宽泛的异常。</p>
<p>例如，父类抛出检查异常IOException，重写的时候不能Exception异常（因为Exception是IOException的父类，只能抛出IOException的子类异常）。</p>
<p><strong>重写规则</strong></p>
<blockquote>
<p>参数列表必须完全与被重写方法的相同；
返回类型必须完全与被重写方法的返回类型相同；
访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
父类的成员方法只能被它的子类重写。
声明为final的方法不能被重写。
声明为static的方法不能被重写，但是能够被再次声明。
子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
构造方法不能被重写。
如果不能继承一个方法，则不能重写这个方法。</p>
</blockquote>
<p>可以使用super来调用父类被重写的方法。</p>
<h3 id="252">2.5.2 重载<a class="headerlink" href="#252" title="Permanent link"></a></h3>
<p>在同一个类中，方法名字相同，但是参数不同。</p>
<p><strong>重载规则</strong></p>
<blockquote>
<p>被重载的方法必须改变参数列表(参数个数或类型不一样)；
被重载的方法可以改变返回类型；
被重载的方法可以改变访问修饰符；
被重载的方法可以声明新的或更广的检查异常；
方法能够在同一个类中或者在一个子类中被重载。
无法以返回值类型作为重载函数的区分标准。</p>
</blockquote>
<h3 id="253">2.5.3 重写与重载的区别<a class="headerlink" href="#253" title="Permanent link"></a></h3>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="26">2.6 多态<a class="headerlink" href="#26" title="Permanent link"></a></h2>
<h3 id="261">2.6.1 介绍<a class="headerlink" href="#261" title="Permanent link"></a></h3>
<p>同一个行为具有多个不同表现形式或者形态的能力。</p>
<p>下面使用instanceof实现了识别不通的类，进行不同的操作（多态）。
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">show</span><span class="o">(</span><span class="k">new</span> <span class="n">Cat</span><span class="o">());</span>  <span class="c1">// 以 Cat 对象调用 show 方法</span>
      <span class="n">show</span><span class="o">(</span><span class="k">new</span> <span class="n">Dog</span><span class="o">());</span>  <span class="c1">// 以 Dog 对象调用 show 方法</span>

      <span class="n">Animal</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cat</span><span class="o">();</span>  <span class="c1">// 向上转型  </span>
      <span class="n">a</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>               <span class="c1">// 调用的是 Cat 的 eat</span>
      <span class="n">Cat</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">Cat</span><span class="o">)</span><span class="n">a</span><span class="o">;</span>        <span class="c1">// 向下转型  </span>
      <span class="n">c</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>        <span class="c1">// 调用的是 Cat 的 work</span>
  <span class="o">}</span>  

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(</span><span class="n">Animal</span> <span class="n">a</span><span class="o">)</span>  <span class="o">{</span>
      <span class="n">a</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>  
        <span class="c1">// 类型判断</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="k">instanceof</span> <span class="n">Cat</span><span class="o">)</span>  <span class="o">{</span>  <span class="c1">// 猫做的事情 </span>
            <span class="n">Cat</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">Cat</span><span class="o">)</span><span class="n">a</span><span class="o">;</span>  
            <span class="n">c</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>  
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="k">instanceof</span> <span class="n">Dog</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 狗做的事情 </span>
            <span class="n">Dog</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">Dog</span><span class="o">)</span><span class="n">a</span><span class="o">;</span>  
            <span class="n">c</span><span class="o">.</span><span class="na">work</span><span class="o">();</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>

<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>  
    <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>  
<span class="o">}</span>  

<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>  
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;吃鱼&quot;</span><span class="o">);</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>  
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;抓老鼠&quot;</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>  

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>  
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;吃骨头&quot;</span><span class="o">);</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>  
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;看家&quot;</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</pre></div></p>
<ul>
<li>Java对比C++(多态)</li>
</ul>
<p>C++的多态通过定义虚函数来实现，即用virtual来声明方法，子类可以重新定义该方法。如果在父类中没有声明virtual则子类对象实际调用的是父类的方法。</p>
<p>Java中，当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。</p>
<blockquote>
<p>C++的虚函数可以在子类中重写，调用是根据实际的对象来判别的，而不是通过指针类型(普通函数的调用是根据当前指针类型来判断的)。纯虚函数是一种在父函数中只定义而不实现的一种函数，不能用来声明对象，也可以被称为抽象类。纯虚函数的实现也可以在类声明外进行定义。C++中的抽象类abstract class是指至少有一个纯虚函数的类，如果一个类全部由纯虚函数组成，不包括任何的实现，被称为纯虚类。</p>
<p>Java中的普通函数自带虚函数功能，调用是根据指针所指向的对象的类型进行判断的。Java中没有virtual这个关键字，java管虚函数叫abstract function，管抽象类叫做abstract class，没有pure这个概念，而是发明了一种叫接口interface的东西来代替纯虚类。interface和abstract class的区别就类似于C++中一般抽象类和纯虚类的区别。</p>
<p>抽象类只能作为基类来使用，不能被定义对象，其纯虚函数的实现在派生类中，如果派生类也没有给出实现，则该派生类还是一个抽象类，只有给出了纯虚函数实现的派生类才能建立对象。由此看出抽象类是注孤生的节奏啊，永远没有对象。</p>
</blockquote>
<h3 id="262">2.6.2 多态的实现方法<a class="headerlink" href="#262" title="Permanent link"></a></h3>
<p>1、重写</p>
<p>Java函数自带重写功能，不需要像C++一样声明virtual。（C++父类声明virtual方法，才能在子类中重写）</p>
<p>2、接口</p>
<p>Java用interface声明接口，用implement继承接口。</p>
<p>3、抽象类和抽象方法</p>
<p>抽象类不能实例化对象，必须被继承后才能使用。</p>
<p>抽象方法即在父类中声明该方法为抽象方法，具体实现由子类决定。</p>
<h2 id="27-java">2.7 Java封装<a class="headerlink" href="#27-java" title="Permanent link"></a></h2>
<p>比如把属性和变量设为pirvate，并只能通过方法名来获取或者重新赋值。</p>
<h2 id="28-java">2.8 Java接口<a class="headerlink" href="#28-java" title="Permanent link"></a></h2>
<p>[可见度] interface 接口名称[extends 其他接口]</p>
<p>注：这里的extends没有错误，接口和接口通过exterds继承，并且可以<strong>多继承</strong>。</p>
<p>只能够有静态的不能被修改的数据成员，即public static final。不过在interface中一般不定义数据成员。</p>
<p>接口中的方法都必须时抽象方法，不能包含除了static和final的变量。<strong>接口是需要被类实现的，接口的方法没有具体的实现。</strong></p>
<p><strong>接口的意义</strong></p>
<p>可以理解成统一的协议，实现类和接口分离。</p>
<h2 id="29">2.9 标记接口<a class="headerlink" href="#29" title="Permanent link"></a></h2>
<p>没有包含任何方法和属性的接口。</p>
<p>作用：</p>
<p>1、建立一个公共的父接口</p>
<p>比如EventListener接口，由几十个其他接口拓展的Java API，可以用一个标记接口建立一组接口的父接口。</p>
<p>如果继承了EventListener接口，JVM就知道该接口将要备用与一个事件的代理方案。</p>
<p><strong>可以用if(obj instanceof &hellip;)进行类型查询。</strong></p>
<p>2、向一个类添加数据类型</p>
<h2 id="210-java">2.10 Java包<a class="headerlink" href="#210-java" title="Permanent link"></a></h2>
<h3 id="2101">2.10.1 包的作用<a class="headerlink" href="#2101" title="Permanent link"></a></h3>
<p>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</p>
<p>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</p>
<p>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</p>
<h3 id="2102">2.10.2 包的使用<a class="headerlink" href="#2102" title="Permanent link"></a></h3>
<p>package pkg1[.pkg2[.pkg3&hellip;]]</p>
<ul>
<li>package创建包</li>
</ul>
<p>创建一个目录，包放置其中，并用&rdquo;package 目录名&rdquo;来声明。</p>
<div class="codehilite"><pre><span class="cm">/* 文件名: Animal.java */</span>
<span class="c1">//如果一个源文件中没有使用包声明，则其中的类、函数、枚举、注释等将放在一个无名的包中</span>
<span class="kn">package</span> <span class="nn">animals</span><span class="o">;</span>  <span class="c1">//包声明应该在源文件的第一行，每个源文件只能包含一个包声明</span>

<span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">travel</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>

<ul>
<li>import导入包</li>
</ul>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">pkg1</span><span class="o">[.</span><span class="na">pkg2</span><span class="o">..].(</span><span class="n">classname</span><span class="o">|</span><span class="err">\</span><span class="o">*);</span>
</pre></div>

<ul>
<li>package的目录结构</li>
</ul>
<p>通常一个公司使用它互联网域名的颠倒形式来作为它的包名。</p>
<p>例如....\com\runoob\test\Runoob.java</p>
<h1 id="3java">3、Java高级编程<a class="headerlink" href="#3java" title="Permanent link"></a></h1>
<h2 id="31">3.1 数据结构<a class="headerlink" href="#31" title="Permanent link"></a></h2>
<h3 id="311-enumeration">3.1.1 枚举(Enumeration)<a class="headerlink" href="#311-enumeration" title="Permanent link"></a></h3>
<p>枚举接口定义了一种从数据结构中取回连续元素的方式。</p>
<p>方法：（传统的接口已经被迭代器取代）</p>
<table>
<thead>
<tr>
<th>boolean hasMoreElements( )</th>
<th>测试此枚举是否包含更多的元素。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object nextElement( )</td>
<td>如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。</td>
</tr>
</tbody>
</table>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.Vector</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Enumeration</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EnumerationTester</span> <span class="o">{</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
      <span class="n">Enumeration</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">days</span><span class="o">;</span><span class="c1">//定义一个枚举</span>
      <span class="n">Vector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">dayNames</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
      <span class="n">dayNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Sunday&quot;</span><span class="o">);</span>
      <span class="n">dayNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Monday&quot;</span><span class="o">);</span>
      <span class="n">dayNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Tuesday&quot;</span><span class="o">);</span>
      <span class="n">dayNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Wednesday&quot;</span><span class="o">);</span>
      <span class="n">dayNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Thursday&quot;</span><span class="o">);</span>
      <span class="n">dayNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Friday&quot;</span><span class="o">);</span>
      <span class="n">dayNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Saturday&quot;</span><span class="o">);</span>
      <span class="n">days</span> <span class="o">=</span> <span class="n">dayNames</span><span class="o">.</span><span class="na">elements</span><span class="o">();</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">days</span><span class="o">.</span><span class="na">hasMoreElements</span><span class="o">()){</span>  <span class="c1">//测试此枚举是否包含更多的元素</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">days</span><span class="o">.</span><span class="na">nextElement</span><span class="o">());</span> <span class="c1">//返回枚举的下一个元素</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3 id="312-bitset">3.1.2 位集合(BitSet)<a class="headerlink" href="#312-bitset" title="Permanent link"></a></h3>
<p>位集合类实现了一组可以单独设置和清除的位和标志。</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.BitSet</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BitSetDemo</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
     <span class="n">BitSet</span> <span class="n">bits1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BitSet</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span><span class="c1">//指定16位，初始化为0</span>
     <span class="n">BitSet</span> <span class="n">bits2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BitSet</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span>

     <span class="c1">// set some bits</span>
     <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">((</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">bits1</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">if</span><span class="o">((</span><span class="n">i</span><span class="o">%</span><span class="mi">5</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">bits2</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
     <span class="o">}</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Initial pattern in bits1: &quot;</span><span class="o">);</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bits1</span><span class="o">);</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;\nInitial pattern in bits2: &quot;</span><span class="o">);</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bits2</span><span class="o">);</span>

     <span class="c1">// AND bits，逻辑与</span>
     <span class="n">bits2</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">bits1</span><span class="o">);</span><span class="c1">//这里bits2变成了逻辑与后的值</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;\nbits2 AND bits1: &quot;</span><span class="o">);</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bits2</span><span class="o">);</span>

     <span class="c1">// OR bits</span>
     <span class="n">bits2</span><span class="o">.</span><span class="na">or</span><span class="o">(</span><span class="n">bits1</span><span class="o">);</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;\nbits2 OR bits1: &quot;</span><span class="o">);</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bits2</span><span class="o">);</span>

     <span class="c1">// XOR bits</span>
     <span class="n">bits2</span><span class="o">.</span><span class="na">xor</span><span class="o">(</span><span class="n">bits1</span><span class="o">);</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;\nbits2 XOR bits1: &quot;</span><span class="o">);</span>
     <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bits2</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>输出：</p>
<div class="codehilite"><pre>Initial pattern in bits1:
{0, 2, 4, 6, 8, 10, 12, 14}

Initial pattern in bits2:
{1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14}

bits2 AND bits1:   
{2, 4, 6, 8, 12, 14}

bits2 OR bits1:   // bits2 = {2, 4, 6, 8, 12, 14} 
{0, 2, 4, 6, 8, 10, 12, 14}

bits2 XOR bits1:   // bits2 = {0, 2, 4, 6, 8, 10, 12, 14}
{}
</pre></div>

<h3 id="313-vector">3.1.3 向量(Vector)<a class="headerlink" href="#313-vector" title="Permanent link"></a></h3>
<div class="codehilite"><pre><span class="n">Vector</span><span class="o">();</span><span class="c1">//建立一个默认的向量，长度10</span>
<span class="n">Vector</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">);</span><span class="c1">//指定大小</span>
<span class="n">Vector</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">,</span><span class="kt">int</span> <span class="n">incr</span><span class="o">);</span><span class="c1">//指定大小，并增量用incr指定</span>
<span class="n">Vector</span><span class="o">(</span><span class="n">Collection</span> <span class="n">c</span><span class="o">);</span><span class="c1">//创建一个包含集合c元素的向量</span>
</pre></div>

<p>具体方法见菜鸟。</p>
<h3 id="314-stack">3.1.4 栈(Stack)<a class="headerlink" href="#314-stack" title="Permanent link"></a></h3>
<p>方法</p>
<div class="codehilite"><pre>Stack();//  创建一个默认的栈
boolean empty();//测试栈是否为空
Object peek( );//查看栈顶，但不弹出
Object pop( );//移除堆栈顶部的对象，并作为此函数的值返回该对象。
Object push(Object element);//把项压入堆栈顶部。
int search(Object element);//返回对象在堆栈中的位置，以 1 为基数。
</pre></div>

<h3 id="315-dictionary">3.1.5 字典Dictionary<a class="headerlink" href="#315-dictionary" title="Permanent link"></a></h3>
<ul>
<li>字典类</li>
</ul>
<p>字典<strong>类</strong>是一个抽象类，定义了键映射到值的数据结构。</p>
<p>字典已经过时，实际开发中，可以实现Map接口来获取键/值的存储关系。</p>
<ul>
<li>Map<strong>接口</strong></li>
</ul>
<p>map已经代替了字典dictionary。</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CollectionsDemo</span> <span class="o">{</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Map</span> <span class="n">m1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">();</span> <span class="c1">//hashmap</span>
      <span class="n">m1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;Zara&quot;</span><span class="o">,</span> <span class="s">&quot;8&quot;</span><span class="o">);</span>
      <span class="n">m1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;Mahnaz&quot;</span><span class="o">,</span> <span class="s">&quot;31&quot;</span><span class="o">);</span>
      <span class="n">m1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;Ayan&quot;</span><span class="o">,</span> <span class="s">&quot;12&quot;</span><span class="o">);</span>
      <span class="n">m1</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;Daisy&quot;</span><span class="o">,</span> <span class="s">&quot;14&quot;</span><span class="o">);</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot; Map Elements&quot;</span><span class="o">);</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&quot;\t&quot;</span> <span class="o">+</span> <span class="n">m1</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<ul>
<li>使用规则</li>
</ul>
<blockquote>
<p>给定一个键和一个值，你可以将该值存储在一个Map对象. 之后，你可以通过键来访问对应的值。
当访问的值不存在的时候，方法就会抛出一个NoSuchElementException异常.
当对象的类型和Map里元素类型不兼容的时候，就会抛出一个 ClassCastException异常。
当在不允许使用Null对象的Map中使用Null对象，会抛出一个NullPointerException 异常。
当尝试修改一个只读的Map时，会抛出一个UnsupportedOperationException异常。</p>
</blockquote>
<div class="codehilite"><pre>void clear( )
 从此映射中移除所有映射关系（可选操作）。
boolean containsKey(Object k)
如果此映射包含指定键的映射关系，则返回 true。
boolean containsValue(Object v)
如果此映射将一个或多个键映射到指定值，则返回 true。
Set entrySet( )
返回此映射中包含的映射关系的 Set 视图。
boolean equals(Object obj)
比较指定的对象与此映射是否相等。
Object get(Object k)
返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。
int hashCode( )
返回此映射的哈希码值。
boolean isEmpty( )
如果此映射未包含键-值映射关系，则返回 true。
Set keySet( )
返回此映射中包含的键的 Set 视图。
Object put(Object k, Object v)
将指定的值与此映射中的指定键关联（可选操作）。
void putAll(Map m)
从指定映射中将所有映射关系复制到此映射中（可选操作）。
Object remove(Object k)
如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。
int size( )
返回此映射中的键-值映射关系数。
Collection values( )
返回此映射中包含的值的 Collection 视图。
</pre></div>

<h3 id="316-hashtable">3.1.6 哈希表(Hashtable)<a class="headerlink" href="#316-hashtable" title="Permanent link"></a></h3>
<p>哈希表是java.util的一部分，是Dictionary具体的实现，提供了一种在用户定义键结构的基础上组织数据的手段。Hashtable类和HashMap类很相似，但是Hashtable支持同步。</p>
<p>Hashtable也存储键/值对。</p>
<p>例如，在地址列表的哈希表中，可以根据邮政编码作为键来存储和排序数据，而不是通过人名。</p>
<ul>
<li>构造方法</li>
</ul>
<div class="codehilite"><pre><span class="n">Hashtable</span><span class="o">();</span>
<span class="n">Hashtable</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span> <span class="o">);</span>
<span class="n">Hashtable</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">,</span><span class="kt">float</span> <span class="n">fillRatio</span><span class="o">);</span><span class="c1">//通过fillRatio指定填充比例，介于0.0至1.0之间，决定了哈希表在重新调整大小之前的充满程度</span>
<span class="n">Hashtable</span><span class="o">(</span><span class="n">Map</span> <span class="n">m</span><span class="o">);</span><span class="c1">//构建一个以m中元素为初始化元素的哈希表，哈希表容量设置为m的两倍</span>
</pre></div>

<p><strong>Hashtable包括Map接口中定义的方法</strong>，还定义了：</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">clear</span><span class="o">(</span> <span class="o">)</span>
 <span class="n">将此哈希表清空</span><span class="err">，</span><span class="n">使其不包含任何键</span><span class="err">。</span>
<span class="n">Object</span> <span class="nf">clone</span><span class="o">(</span> <span class="o">)</span>
<span class="n">创建此哈希表的浅表副本</span><span class="err">。</span>
<span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="n">Object</span> <span class="n">value</span><span class="o">)</span>
 <span class="n">测试此映射表中是否存在与指定值关联的键</span><span class="err">。</span>
<span class="kt">boolean</span> <span class="nf">containsKey</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span>
<span class="n">测试指定对象是否为此哈希表中的键</span><span class="err">。</span>
<span class="kt">boolean</span> <span class="nf">containsValue</span><span class="o">(</span><span class="n">Object</span> <span class="n">value</span><span class="o">)</span>
<span class="n">如果此</span> <span class="n">Hashtable</span> <span class="n">将一个或多个键映射到此值</span><span class="err">，</span><span class="n">则返回</span> <span class="kc">true</span><span class="err">。</span>
<span class="n">Enumeration</span> <span class="nf">elements</span><span class="o">(</span> <span class="o">)</span>
<span class="n">返回此哈希表中的值的枚举</span><span class="err">。</span>
<span class="n">Object</span> <span class="nf">get</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span>
 <span class="n">返回指定键所映射到的值</span><span class="err">，</span><span class="n">如果此映射不包含此键的映射</span><span class="err">，</span><span class="n">则返回</span> <span class="kc">null</span><span class="o">.</span> <span class="n">更确切地讲</span><span class="err">，</span><span class="n">如果此映射包含满足</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="n">的从键</span> <span class="n">k</span> <span class="n">到值</span> <span class="n">v</span> <span class="n">的映射</span><span class="err">，</span><span class="n">则此方法返回</span> <span class="n">v</span><span class="err">；</span><span class="n">否则</span><span class="err">，</span><span class="n">返回</span> <span class="kc">null</span><span class="err">。</span>
<span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">(</span> <span class="o">)</span>
<span class="n">测试此哈希表是否没有键映射到值</span><span class="err">。</span>
<span class="n">Enumeration</span> <span class="nf">keys</span><span class="o">(</span> <span class="o">)</span>
 <span class="n">返回此哈希表中的键的枚举</span><span class="err">。</span>
<span class="n">Object</span> <span class="nf">put</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="n">Object</span> <span class="n">value</span><span class="o">)</span>
<span class="n">将指定</span> <span class="n">key</span> <span class="n">映射到此哈希表中的指定</span> <span class="n">value</span><span class="err">。</span>
<span class="kt">void</span> <span class="nf">rehash</span><span class="o">(</span> <span class="o">)</span>
<span class="n">增加此哈希表的容量并在内部对其进行重组</span><span class="err">，</span><span class="n">以便更有效地容纳和访问其元素</span><span class="err">。</span>
<span class="n">Object</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span>
<span class="n">从哈希表中移除该键及其相应的值</span><span class="err">。</span>
<span class="kt">int</span> <span class="nf">size</span><span class="o">(</span> <span class="o">)</span>
 <span class="n">返回此哈希表中的键的数量</span><span class="err">。</span>
<span class="n">String</span> <span class="nf">toString</span><span class="o">(</span> <span class="o">)</span>
<span class="n">返回此</span> <span class="n">Hashtable</span> <span class="n">对象的字符串表示形式</span><span class="err">，</span><span class="n">其形式为</span> <span class="n">ASCII</span> <span class="n">字符</span> <span class="s">&quot;, &quot;</span> <span class="err">（</span><span class="n">逗号加空格</span><span class="err">）</span><span class="n">分隔开的</span><span class="err">、</span><span class="n">括在括号中的一组条目</span><span class="err">。</span>
</pre></div>

<h3 id="317-properties">3.1.7 属性(Properties)<a class="headerlink" href="#317-properties" title="Permanent link"></a></h3>
<p><strong>Properties继承于Hashtable</strong>,表示一个持久的属性集。属性列表中每个键和其对因值都是一个字符串。</p>
<ul>
<li>构造函数</li>
</ul>
<div class="codehilite"><pre><span class="n">Properties</span><span class="o">();</span>
<span class="n">Properties</span><span class="o">(</span><span class="n">Properties</span> <span class="n">propDefault</span><span class="o">);</span><span class="c1">//使用propDefault作为默认值</span>
</pre></div>

<div class="codehilite"><pre><span class="n">String</span> <span class="nf">getProperty</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span>
 <span class="n">用指定的键在此属性列表中搜索属性</span><span class="err">。</span>
<span class="n">String</span> <span class="nf">getProperty</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">String</span> <span class="n">defaultProperty</span><span class="o">)</span>
<span class="n">用指定的键在属性列表中搜索属性</span><span class="err">。</span>
<span class="kt">void</span> <span class="nf">list</span><span class="o">(</span><span class="n">PrintStream</span> <span class="n">streamOut</span><span class="o">)</span>
 <span class="n">将属性列表输出到指定的输出流</span><span class="err">。</span>
<span class="kt">void</span> <span class="nf">list</span><span class="o">(</span><span class="n">PrintWriter</span> <span class="n">streamOut</span><span class="o">)</span>
<span class="n">将属性列表输出到指定的输出流</span><span class="err">。</span>
<span class="kt">void</span> <span class="nf">load</span><span class="o">(</span><span class="n">InputStream</span> <span class="n">streamIn</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span>
 <span class="n">从输入流中读取属性列表</span><span class="err">（</span><span class="n">键和元素对</span><span class="err">）。</span>
<span class="n">Enumeration</span> <span class="nf">propertyNames</span><span class="o">(</span> <span class="o">)</span>
<span class="n">按简单的面向行的格式从输入字符流中读取属性列表</span><span class="err">（</span><span class="n">键和元素对</span><span class="err">）。</span>
<span class="n">Object</span> <span class="nf">setProperty</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">String</span> <span class="n">value</span><span class="o">)</span>
 <span class="n">调用</span> <span class="n">Hashtable</span> <span class="n">的方法</span> <span class="n">put</span><span class="err">。</span>
<span class="kt">void</span> <span class="nf">store</span><span class="o">(</span><span class="n">OutputStream</span> <span class="n">streamOut</span><span class="o">,</span> <span class="n">String</span> <span class="n">description</span><span class="o">)</span>
 <span class="n">以适合使用</span>  <span class="nf">load</span><span class="o">(</span><span class="n">InputStream</span><span class="o">)</span><span class="n">方法加载到</span> <span class="n">Properties</span> <span class="n">表中的格式</span><span class="err">，</span><span class="n">将此</span> <span class="n">Properties</span> <span class="n">表中的属性列表</span><span class="err">（</span><span class="n">键和元素对</span><span class="err">）</span><span class="n">写入输出流</span><span class="err">。</span>
</pre></div>

<p>实例：</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PropDemo</span> <span class="o">{</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
      <span class="n">Properties</span> <span class="n">capitals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
      <span class="n">Set</span> <span class="n">states</span><span class="o">;</span>
      <span class="n">String</span> <span class="n">str</span><span class="o">;</span>

      <span class="n">capitals</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;Illinois&quot;</span><span class="o">,</span> <span class="s">&quot;Springfield&quot;</span><span class="o">);</span><span class="c1">//加入属性</span>
      <span class="n">capitals</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;Missouri&quot;</span><span class="o">,</span> <span class="s">&quot;Jefferson City&quot;</span><span class="o">);</span>
      <span class="n">capitals</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;Washington&quot;</span><span class="o">,</span> <span class="s">&quot;Olympia&quot;</span><span class="o">);</span>
      <span class="n">capitals</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;California&quot;</span><span class="o">,</span> <span class="s">&quot;Sacramento&quot;</span><span class="o">);</span>
      <span class="n">capitals</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;Indiana&quot;</span><span class="o">,</span> <span class="s">&quot;Indianapolis&quot;</span><span class="o">);</span>

      <span class="c1">// Show all states and capitals in hashtable.</span>
      <span class="n">states</span> <span class="o">=</span> <span class="n">capitals</span><span class="o">.</span><span class="na">keySet</span><span class="o">();</span> <span class="c1">// key的set视图</span>
      <span class="n">Iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">states</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span><span class="c1">//生成一个迭代器</span>
      <span class="k">while</span><span class="o">(</span><span class="n">itr</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
         <span class="n">str</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">itr</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;The capital of &quot;</span> <span class="o">+</span>
            <span class="n">str</span> <span class="o">+</span> <span class="s">&quot; is &quot;</span> <span class="o">+</span> <span class="n">capitals</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>

      <span class="c1">// look for state not in list -- specify default</span>
      <span class="n">str</span> <span class="o">=</span> <span class="n">capitals</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">&quot;Florida&quot;</span><span class="o">,</span> <span class="s">&quot;Not Found&quot;</span><span class="o">);</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;The capital of Florida is &quot;</span>
          <span class="o">+</span> <span class="n">str</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<ul>
<li>迭代器</li>
</ul>
<blockquote>
<p>(1) 使用方法 iterator() 要求容器返回一个 Iterator。第一次调用 Iterator 的 next() 方法时，它返回序列的第一个元素。注意：iterator() 方法是 java.lang.Iterable 接口,被 Collection 继承。
(2) 使用 next() 获得序列中的下一个元素。
(3) 使用 hasNext() 检查序列中是否还有元素。
(4) 使用 remove() 将迭代器新返回的元素删除。</p>
</blockquote>
<h2 id="32-java">3.2 Java集合框架<a class="headerlink" href="#32-java" title="Permanent link"></a></h2>
<p>集合框架包括：</p>
<p><strong>接口</strong>：代表集合的抽象数据类型，例如Collection、List、Set、Map。之所以定义多个接口，是为了以不同的方式操作集合对象。</p>
<p><strong>实现(类)</strong>：集合接口的具体体现。它们是可重复使用的数据结构，如ArrayList、LinkedList、HashSet、HashMap等</p>
<p><strong>算法</strong>：实现集合接口的对象里的方法执行的一些有用的计算，如搜索和排序。这些算法被称为多态，因为相同的方法可以在相似的接口上有着不同的实现。</p>
<div class="codehilite"><pre>Collection 接口
Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。
Collection 接口存储一组不唯一，无序的对象。

List 接口
List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。

List 接口存储一组不唯一，有序（插入顺序）的对象。

Set
Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。

Set 接口存储一组唯一，无序的对象。

SortedSet 
继承于Set保存有序的集合。

Map
Map 接口存储一组键值对象，提供key（键）到value（值）的映射。

Map.Entry 
描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。

SortedMap
继承于 Map，使 Key 保持在升序排列。

Enumeration
这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。
</pre></div>

<p><img src="/images/wiki/Java/JavaSets1.gif" width="400" alt="JavaSets1" /></p>
<p><img src="/images/wiki/Java/JavaSets12.png" width="400" alt="JavaSets2" /></p>
<p><strong>List和Set的区别</strong></p>
<ol>
<li>
<p>Set 接口实例存储的是无序的，无法保证每个元素的存储顺序，不重复的数据。List 接口实例存储的是有序的，保持了每个元素的插入顺序，输出的顺序就是插入的顺序，可以重复的元素。</p>
</li>
<li>
<p>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。</p>
</li>
<li>
<p>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。</p>
</li>
</ol>
<ul>
<li>集合实现类</li>
</ul>
<div class="codehilite"><pre>AbstractCollection 
实现了大部分的集合接口。

AbstractList 
继承于AbstractCollection 并且实现了大部分List接口。

AbstractSequentialList 
继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。

LinkedList
该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：
Listlist=Collections.synchronizedList(newLinkedList(...));
LinkedList 查找效率低。

ArrayList
该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。

AbstractSet 
继承于AbstractCollection 并且实现了大部分Set接口。

HashSet
该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。

LinkedHashSet
具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。

TreeSet
该类实现了Set接口，可以实现排序等功能。

AbstractMap 
实现了大部分的Map接口。

HashMap 
HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。
该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。

TreeMap 
继承了AbstractMap，并且使用一颗树。

WeakHashMap 
继承AbstractMap类，使用弱密钥的哈希表。

LinkedHashMap 
继承于HashMap，使用元素的自然顺序对元素进行排序.

IdentityHashMap 
继承AbstractMap类，比较文档时使用引用相等。
</pre></div>

<ul>
<li>迭代器使用</li>
</ul>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
     <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
     <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Hello&quot;</span><span class="o">);</span>
     <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;World&quot;</span><span class="o">);</span>
     <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;HAHAHAHA&quot;</span><span class="o">);</span>
     <span class="c1">//第一种遍历方法使用foreach遍历List</span>
     <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">str</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>            <span class="c1">//也可以改写for(int i=0;i&lt;list.size();i++)这种形式</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
     <span class="o">}</span>

     <span class="c1">//第二种遍历，把链表变为数组相关的内容进行遍历</span>
     <span class="n">String</span><span class="o">[]</span> <span class="n">strArray</span><span class="o">=</span><span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
     <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">strArray</span><span class="o">);</span>
     <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">strArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="c1">//这里也可以改写为  foreach(String str:strArray)这种形式</span>
     <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">strArray</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
     <span class="o">}</span>

    <span class="c1">//第三种遍历 使用迭代器进行相关遍历</span>

     <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ite</span><span class="o">=</span><span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
     <span class="k">while</span><span class="o">(</span><span class="n">ite</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span><span class="c1">//判断下一个元素之后有值</span>
     <span class="o">{</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ite</span><span class="o">.</span><span class="na">next</span><span class="o">());</span>
     <span class="o">}</span>
 <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h2 id="33-java">3.3 Java泛型<a class="headerlink" href="#33-java" title="Permanent link"></a></h2>
<p>泛型提供编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p>
<p>需求：写一个排序方法，能够对整数数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现?</p>
<p>泛型方法在调用时可以接受到不同类型的参数。根据传递给泛型方法的参数类型，编译器适当的处理每一个方法调用。</p>
<h3 id="331">3.3.1 泛型方法<a class="headerlink" href="#331" title="Permanent link"></a></h3>
<ul>
<li>案例</li>
</ul>
<p><strong>如何使用泛型方法打印不同字符串的元素</strong></p>
<p>下面案例，将int、float和char类型泛化，这样就不会出现写三个函数的问题。System.out.printf( &ldquo;%s &ldquo;, element )三者都可以输出，而E[] inputArray也可以是以上三种类型。</p>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericMethodTest</span>
<span class="o">{</span>
   <span class="c1">// 泛型方法 printArray                         </span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span> <span class="n">E</span> <span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">printArray</span><span class="o">(</span> <span class="n">E</span><span class="o">[]</span> <span class="n">inputArray</span> <span class="o">)</span>
   <span class="o">{</span>
      <span class="c1">// 输出数组元素            </span>
         <span class="k">for</span> <span class="o">(</span> <span class="n">E</span> <span class="n">element</span> <span class="o">:</span> <span class="n">inputArray</span> <span class="o">){</span>        <span class="c1">//除了字符型，%s还能输出整型、float型。这里的E用于泛这三种类型</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span> <span class="s">&quot;%s &quot;</span><span class="o">,</span> <span class="n">element</span> <span class="o">);</span>
         <span class="o">}</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span> <span class="n">String</span> <span class="n">args</span><span class="o">[]</span> <span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">// 创建不同类型数组： Integer, Double 和 Character</span>
        <span class="n">Integer</span><span class="o">[]</span> <span class="n">intArray</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span> <span class="o">};</span>
        <span class="n">Double</span><span class="o">[]</span> <span class="n">doubleArray</span> <span class="o">=</span> <span class="o">{</span> <span class="mf">1.1</span><span class="o">,</span> <span class="mf">2.2</span><span class="o">,</span> <span class="mf">3.3</span><span class="o">,</span> <span class="mf">4.4</span> <span class="o">};</span>
        <span class="n">Character</span><span class="o">[]</span> <span class="n">charArray</span> <span class="o">=</span> <span class="o">{</span> <span class="sc">&#39;H&#39;</span><span class="o">,</span> <span class="sc">&#39;E&#39;</span><span class="o">,</span> <span class="sc">&#39;L&#39;</span><span class="o">,</span> <span class="sc">&#39;L&#39;</span><span class="o">,</span> <span class="sc">&#39;O&#39;</span> <span class="o">};</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="s">&quot;整型数组元素为:&quot;</span> <span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span> <span class="n">intArray</span>  <span class="o">);</span> <span class="c1">// 传递一个整型数组</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="s">&quot;\n双精度型数组元素为:&quot;</span> <span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span> <span class="n">doubleArray</span> <span class="o">);</span> <span class="c1">// 传递一个双精度型数组</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="s">&quot;\n字符型数组元素为:&quot;</span> <span class="o">);</span>
        <span class="n">printArray</span><span class="o">(</span> <span class="n">charArray</span> <span class="o">);</span> <span class="c1">// 传递一个字符型数组</span>
    <span class="o">}</span> 
<span class="o">}</span>
</pre></div>

<p>输出：</p>
<div class="codehilite"><pre>整型数组元素为:
1 2 3 4 5 

双精度型数组元素为:
1.1 2.2 3.3 4.4 

字符型数组元素为:
H E L L O   
</pre></div>

<p><strong>&ldquo;extends&rdquo;如何使用在一般意义上的意思&rdquo;extends&rdquo;（类）或者&rdquo;implements&rdquo;（接口）</strong></p>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MaximumTest</span>
<span class="o">{</span>
   <span class="c1">// 比较三个值并返回最大值</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">T</span> <span class="nf">maximum</span><span class="o">(</span><span class="n">T</span> <span class="n">x</span><span class="o">,</span> <span class="n">T</span> <span class="n">y</span><span class="o">,</span> <span class="n">T</span> <span class="n">z</span><span class="o">)</span>
   <span class="o">{</span>                     
      <span class="n">T</span> <span class="n">max</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="c1">// 假设x是初始最大值</span>
      <span class="k">if</span> <span class="o">(</span> <span class="n">y</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span> <span class="n">max</span> <span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">){</span>
         <span class="n">max</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span> <span class="c1">//y 更大</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span> <span class="n">z</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span> <span class="n">max</span> <span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">){</span>
         <span class="n">max</span> <span class="o">=</span> <span class="n">z</span><span class="o">;</span> <span class="c1">// 现在 z 更大           </span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="n">max</span><span class="o">;</span> <span class="c1">// 返回最大对象</span>
   <span class="o">}</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span> <span class="n">String</span> <span class="n">args</span><span class="o">[]</span> <span class="o">)</span>
   <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span> <span class="s">&quot;%d, %d 和 %d 中最大的数为 %d\n\n&quot;</span><span class="o">,</span>
                   <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="n">maximum</span><span class="o">(</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span> <span class="o">)</span> <span class="o">);</span>

      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span> <span class="s">&quot;%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n&quot;</span><span class="o">,</span>
                   <span class="mf">6.6</span><span class="o">,</span> <span class="mf">8.8</span><span class="o">,</span> <span class="mf">7.7</span><span class="o">,</span> <span class="n">maximum</span><span class="o">(</span> <span class="mf">6.6</span><span class="o">,</span> <span class="mf">8.8</span><span class="o">,</span> <span class="mf">7.7</span> <span class="o">)</span> <span class="o">);</span>

      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span> <span class="s">&quot;%s, %s 和 %s 中最大的数为 %s\n&quot;</span><span class="o">,</span><span class="s">&quot;pear&quot;</span><span class="o">,</span>
         <span class="s">&quot;apple&quot;</span><span class="o">,</span> <span class="s">&quot;orange&quot;</span><span class="o">,</span> <span class="n">maximum</span><span class="o">(</span> <span class="s">&quot;pear&quot;</span><span class="o">,</span> <span class="s">&quot;apple&quot;</span><span class="o">,</span> <span class="s">&quot;orange&quot;</span> <span class="o">)</span> <span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>输出：</p>
<div class="codehilite"><pre>3, 4 和 5 中最大的数为 5

6.6, 8.8 和 7.7 中最大的数为 8.8

pear, apple 和 orange 中最大的数为 pear
</pre></div>

<h3 id="322">3.2.2 泛型方法<a class="headerlink" href="#322" title="Permanent link"></a></h3>
<div class="codehilite"><pre>public class Box&lt;T&gt; {

  private T t;

  public void add(T t) {
    this.t = t;
  }

  public T get() {
    return t;
  }

  public static void main(String[] args) {
    Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();//这里指定了Integer类型
    Box&lt;String&gt; stringBox = new Box&lt;String&gt;();

    integerBox.add(new Integer(10));
    stringBox.add(new String(&quot;菜鸟教程&quot;));

    System.out.printf(&quot;整型值为 :%d\n\n&quot;, integerBox.get());
    System.out.printf(&quot;字符串为 :%s\n&quot;, stringBox.get());
  }
}
</pre></div>

<h3 id="323">3.2.3 类型通配符<a class="headerlink" href="#323" title="Permanent link"></a></h3>
<p>类型通配符一般使用?代替具体的类型参数。例如，List&lt;?&gt;在逻辑上是List<String> ,List<Integer>等所有List&lt;具体类型实参&gt;的父类。</p>
<p>1、案例1</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">age</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">number</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;();</span>

        <span class="n">name</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;icon&quot;</span><span class="o">);</span>
        <span class="n">age</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">18</span><span class="o">);</span>
        <span class="n">number</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">314</span><span class="o">);</span>

        <span class="n">getData</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="n">getData</span><span class="o">(</span><span class="n">age</span><span class="o">);</span>
        <span class="n">getData</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>

   <span class="o">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getData</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;data :&quot;</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>输出：</p>
<div class="codehilite"><pre>data :icon
data :18
data :314
</pre></div>

<p>2、案例2（通配符上限）</p>
<p>类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GenericTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">age</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">number</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Number</span><span class="o">&gt;();</span>

        <span class="n">name</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;icon&quot;</span><span class="o">);</span>
        <span class="n">age</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">18</span><span class="o">);</span>
        <span class="n">number</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">314</span><span class="o">);</span>

        <span class="c1">//getUperNumber(name);//1，由于getUperNumber定义时，extendsNumber，限制了参数泛型的上限为Number，所以String不在这个范围内 </span>
        <span class="n">getUperNumber</span><span class="o">(</span><span class="n">age</span><span class="o">);</span><span class="c1">//2</span>
        <span class="n">getUperNumber</span><span class="o">(</span><span class="n">number</span><span class="o">);</span><span class="c1">//3</span>

   <span class="o">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getData</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?&gt;</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;data :&quot;</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">getUperNumber</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Number</span><span class="o">&gt;</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>    <span class="c1">//这里extends表示通配符所代表的类型是T类型的子类。如果想要代表父类，换成super。</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;data :&quot;</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
       <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<ul>
<li>通配符的extends和super区别</li>
</ul>
<? extends T>表示该通配符所代表的类型是T类型的子类。

<? super T>表示该通配符所代表的类型是T类型的父类。

<p>类型通配符下限通过形如 List&lt;? super Number&gt;来定义，表示类型只能接受Number及其三层父类类型，如Objec类型的实例。</p>
<h2 id="33-java_1">3.3 Java序列化<a class="headerlink" href="#33-java_1" title="Permanent link"></a></h2>
<p>序列化机制：一个对象可以被表示为一个字节序列，该字节序列包括对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p>
<p>将序列化对象写入文件后，可以从文件中读取出来，并且对它进行反序列化，即对象的类型信息、对象的数据和对象中的数据类型可以在内存中新建对象。</p>
<p>类ObjectInputStream和ObjectOutputStream是高层次的数据流，包括反序列化和序列化对象的方法。</p>
<p>ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外：</p>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">writeObject</span><span class="o">(</span><span class="n">Object</span> <span class="n">x</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">;</span><span class="c1">//序列化一个对象，并将它发送到输出流。</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="n">Object</span> <span class="nf">readObject</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">ClassNotFoundException</span><span class="o">;</span><span class="c1">//从流中取出下一个对象，并将对象反序列化。</span>
</pre></div>

<h3 id="331_1">3.3.1 序列化对象<a class="headerlink" href="#331_1" title="Permanent link"></a></h3>
<p>序列化的两个条件：</p>
<p>1、该类必须实现java.io.Serializable对象</p>
<p>2、该类的所有属性必须是可序列化的。如果有一个属性不可序列化，则该属性必须注明是短暂的。</p>
<p>Java标准类是否可序列化，可查看该类的文档。确定该类有没有实现java.io.Serializable接口。</p>
<div class="codehilite"><pre><span class="c1">//首先定义一个要序列化的对象</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span>
<span class="o">{</span>
   <span class="kd">public</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
   <span class="kd">public</span> <span class="n">String</span> <span class="n">address</span><span class="o">;</span>
   <span class="kd">public</span> <span class="kd">transient</span> <span class="kt">int</span> <span class="n">SSN</span><span class="o">;</span><span class="c1">//transient表示序列化的时候，不会序列化到指定的目的地中。</span>
   <span class="kd">public</span> <span class="kt">int</span> <span class="n">number</span><span class="o">;</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mailCheck</span><span class="o">()</span>
   <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Mailing a check to &quot;</span> <span class="o">+</span> <span class="n">name</span>
                           <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">address</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//序列化</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SerializeDemo</span>
<span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
   <span class="o">{</span>
      <span class="n">Employee</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="o">();</span>
      <span class="n">e</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">&quot;Reyan Ali&quot;</span><span class="o">;</span>
      <span class="n">e</span><span class="o">.</span><span class="na">address</span> <span class="o">=</span> <span class="s">&quot;Phokka Kuan, Ambehta Peer&quot;</span><span class="o">;</span>
      <span class="n">e</span><span class="o">.</span><span class="na">SSN</span> <span class="o">=</span> <span class="mi">11122333</span><span class="o">;</span>
      <span class="n">e</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="mi">101</span><span class="o">;</span>
      <span class="k">try</span>
      <span class="o">{</span>
         <span class="n">FileOutputStream</span> <span class="n">fileOut</span> <span class="o">=</span>
         <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="s">&quot;/tmp/employee.ser&quot;</span><span class="o">);</span><span class="c1">//文件输出流</span>
         <span class="n">ObjectOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectOutputStream</span><span class="o">(</span><span class="n">fileOut</span><span class="o">);</span><span class="c1">//对象输出流，输出到fileOut文件</span>
         <span class="n">out</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
         <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
         <span class="n">fileOut</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&quot;Serialized data is saved in /tmp/employee.ser&quot;</span><span class="o">);</span>
      <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">IOException</span> <span class="n">i</span><span class="o">)</span>
      <span class="o">{</span>
          <span class="n">i</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3 id="332">3.3.2 反序列化对象<a class="headerlink" href="#332" title="Permanent link"></a></h3>
<div class="codehilite"><pre><span class="c1">//反序列化</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeserializeDemo</span>
<span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
   <span class="o">{</span>
      <span class="n">Employee</span> <span class="n">e</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="k">try</span>
      <span class="o">{</span>
         <span class="n">FileInputStream</span> <span class="n">fileIn</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="s">&quot;/tmp/employee.ser&quot;</span><span class="o">);</span><span class="c1">//文件输入流</span>
         <span class="n">ObjectInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ObjectInputStream</span><span class="o">(</span><span class="n">fileIn</span><span class="o">);</span><span class="c1">//对象输入流，输入fileIn这个流</span>
         <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="n">Employee</span><span class="o">)</span> <span class="n">in</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span><span class="c1">//这里需要将反序列化后，进行Object指定</span>
         <span class="n">in</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
         <span class="n">fileIn</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
      <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">IOException</span> <span class="n">i</span><span class="o">)</span>
      <span class="o">{</span>
         <span class="n">i</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
         <span class="k">return</span><span class="o">;</span>
      <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">c</span><span class="o">)</span><span class="c1">//如果JVM反序列化对象的过程中找不到该类，就会抛出该异常</span>
      <span class="o">{</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Employee class not found&quot;</span><span class="o">);</span>
         <span class="n">c</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
         <span class="k">return</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Deserialized Employee...&quot;</span><span class="o">);</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Name: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Address: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">address</span><span class="o">);</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;SSN: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">SSN</span><span class="o">);</span><span class="c1">//SSN是transient，所以没有序列化，在反序列化后，SSN属性为0</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Number: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">number</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>输出：</p>
<div class="codehilite"><pre>Deserialized Employee...
Name: Reyan Ali
Address:Phokka Kuan, Ambehta Peer
SSN: 0
Number:101
</pre></div>

<h2 id="34">3.4 多线程<a class="headerlink" href="#34" title="Permanent link"></a></h2>
<h3 id="341">3.4.1 线程的优先级<a class="headerlink" href="#341" title="Permanent link"></a></h3>
<p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p>
<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。</p>
<h3 id="342">3.4.2 创建线程的方法<a class="headerlink" href="#342" title="Permanent link"></a></h3>
<p>1、通过实现 Runnable 接口；</p>
<p>2、通过继承 Thread 类本身；</p>
<p>3、通过 Callable 和 Future 创建线程。</p>
<h3 id="343-runnable">3.4.3 Runnable接口<a class="headerlink" href="#343-runnable" title="Permanent link"></a></h3>
<p>构造方法有多个</p>
<div class="codehilite"><pre><span class="n">Thread</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">threadOb</span><span class="o">,</span><span class="n">String</span> <span class="n">threadName</span><span class="o">);</span>
</pre></div>

<p>一个类只需要执行一个方法调用 run()</p>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span>
</pre></div>

<p>新线程创建之后，你调用它的 start() 方法它才会运行。</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">start</span><span class="o">();</span>
</pre></div>

<p>实例：</p>
<div class="codehilite"><pre><span class="kd">class</span> <span class="nc">RunnableDemo</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="n">Thread</span> <span class="n">t</span><span class="o">;</span>
   <span class="kd">private</span> <span class="n">String</span> <span class="n">threadName</span><span class="o">;</span>

   <span class="n">RunnableDemo</span><span class="o">(</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">threadName</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Creating &quot;</span> <span class="o">+</span>  <span class="n">threadName</span> <span class="o">);</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Running &quot;</span> <span class="o">+</span>  <span class="n">threadName</span> <span class="o">);</span>
      <span class="k">try</span> <span class="o">{</span>
         <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Thread: &quot;</span> <span class="o">+</span> <span class="n">threadName</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
            <span class="c1">// 让线程睡眠一会</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
         <span class="o">}</span>
      <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Thread &quot;</span> <span class="o">+</span>  <span class="n">threadName</span> <span class="o">+</span> <span class="s">&quot; interrupted.&quot;</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Thread &quot;</span> <span class="o">+</span>  <span class="n">threadName</span> <span class="o">+</span> <span class="s">&quot; exiting.&quot;</span><span class="o">);</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span> <span class="o">()</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Starting &quot;</span> <span class="o">+</span>  <span class="n">threadName</span> <span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span> <span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">threadName</span><span class="o">);</span>
         <span class="n">t</span><span class="o">.</span><span class="na">start</span> <span class="o">();</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestThread</span> <span class="o">{</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
      <span class="n">RunnableDemo</span> <span class="n">R1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RunnableDemo</span><span class="o">(</span> <span class="s">&quot;Thread-1&quot;</span><span class="o">);</span>
      <span class="n">R1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

      <span class="n">RunnableDemo</span> <span class="n">R2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RunnableDemo</span><span class="o">(</span> <span class="s">&quot;Thread-2&quot;</span><span class="o">);</span>
      <span class="n">R2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
   <span class="o">}</span>   
<span class="o">}</span>
</pre></div>

<h3 id="344-tread">3.4.4 继承Tread类<a class="headerlink" href="#344-tread" title="Permanent link"></a></h3>
<p>本质上Tread是实现了接口Runnable的实例。</p>
<div class="codehilite"><pre><span class="kd">class</span> <span class="nc">ThreadDemo</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="n">Thread</span> <span class="n">t</span><span class="o">;</span>
   <span class="kd">private</span> <span class="n">String</span> <span class="n">threadName</span><span class="o">;</span>

   <span class="n">ThreadDemo</span><span class="o">(</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">threadName</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Creating &quot;</span> <span class="o">+</span>  <span class="n">threadName</span> <span class="o">);</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Running &quot;</span> <span class="o">+</span>  <span class="n">threadName</span> <span class="o">);</span>
      <span class="k">try</span> <span class="o">{</span>
         <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Thread: &quot;</span> <span class="o">+</span> <span class="n">threadName</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
            <span class="c1">// 让线程睡眠一会</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
         <span class="o">}</span>
      <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Thread &quot;</span> <span class="o">+</span>  <span class="n">threadName</span> <span class="o">+</span> <span class="s">&quot; interrupted.&quot;</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Thread &quot;</span> <span class="o">+</span>  <span class="n">threadName</span> <span class="o">+</span> <span class="s">&quot; exiting.&quot;</span><span class="o">);</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span> <span class="o">()</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Starting &quot;</span> <span class="o">+</span>  <span class="n">threadName</span> <span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span> <span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">threadName</span><span class="o">);</span>
         <span class="n">t</span><span class="o">.</span><span class="na">start</span> <span class="o">();</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestThread</span> <span class="o">{</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>
      <span class="n">ThreadDemo</span> <span class="n">T1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadDemo</span><span class="o">(</span> <span class="s">&quot;Thread-1&quot;</span><span class="o">);</span>
      <span class="n">T1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

      <span class="n">ThreadDemo</span> <span class="n">T2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadDemo</span><span class="o">(</span> <span class="s">&quot;Thread-2&quot;</span><span class="o">);</span>
      <span class="n">T2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
   <span class="o">}</span>   
<span class="o">}</span>
</pre></div>

<p>Thread类对象的方法</p>
<p>|1 | public void start()
使该线程开始执行；Java 虚拟机调用该线程的 run 方法。|
|-|-|
|2 | public void run()
如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。|
|-|-|
|3 | public final void setName(String name)
改变线程名称，使之与参数 name 相同。|
|-|-|
|4 | public final void setPriority(int priority)
 更改线程的优先级。|
|-|-|
|5 | public final void setDaemon(boolean on)
将该线程标记为守护线程或用户线程。|
|-|-|
|6 | public final void join(long millisec)
等待该线程终止的时间最长为 millis 毫秒。|
|-|-|
|7 | public void interrupt()
中断线程。|
|-|-|
|8 | public final boolean isAlive()
测试线程是否处于活动状态。|</p>
<p>Thread类的静态fangfa</p>
<p>|1 | public static void yield()
暂停当前正在执行的线程对象，并执行其他线程。|
|-|-|
|2 | public static void sleep(long millisec)
在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。|
|-|-|
|3 | public static boolean holdsLock(Object x)
当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。|
|-|-|
|4 | public static Thread currentThread()
返回对当前正在执行的线程对象的引用。|
|-|-|
|5 |public static void dumpStack()
将当前线程的堆栈跟踪打印至标准错误流。|</p>
<h3 id="345-callablefuture">3.4.5 Callable和Future创建线程<a class="headerlink" href="#345-callablefuture" title="Permanent link"></a></h3>
<ol>
<li>
<p>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</p>
</li>
<li>
<p>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</p>
</li>
<li>
<p>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</p>
</li>
<li>
<p>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</p>
</li>
</ol>
<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CallableThreadTest</span> <span class="kd">implements</span> <span class="n">Callable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>  
    <span class="o">{</span>  
        <span class="n">CallableThreadTest</span> <span class="n">ctt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CallableThreadTest</span><span class="o">();</span>  
        <span class="n">FutureTask</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ft</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FutureTask</span><span class="o">&lt;&gt;(</span><span class="n">ctt</span><span class="o">);</span>  
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span>  
        <span class="o">{</span>  
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">&quot; 的循环变量i的值&quot;</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>  
            <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="mi">20</span><span class="o">)</span>  
            <span class="o">{</span>  
                <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="n">ft</span><span class="o">,</span><span class="s">&quot;有返回值的线程&quot;</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>  
            <span class="o">}</span>  
        <span class="o">}</span>  
        <span class="k">try</span>  
        <span class="o">{</span>  
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;子线程的返回值：&quot;</span><span class="o">+</span><span class="n">ft</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span>  
        <span class="o">{</span>  
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExecutionException</span> <span class="n">e</span><span class="o">)</span>  
        <span class="o">{</span>  
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>  
        <span class="o">}</span>  

    <span class="o">}</span>
    <span class="nd">@Override</span>  
    <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span>  
    <span class="o">{</span>  
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  
        <span class="k">for</span><span class="o">(;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span>  
        <span class="o">{</span>  
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>  
        <span class="o">}</span>  
        <span class="k">return</span> <span class="n">i</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</pre></div>

<h3 id="346">3.4.6 线程池<a class="headerlink" href="#346" title="Permanent link"></a></h3>
<p>容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源</p>
<p>在java中，如果每个请求到达就创建一个新线程，开销是相当大的。在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。为了防止资源不足，需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务。（为什么）</p>
<p>线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快；另外，通过适当的调整线程中的线程数目可以防止出现资源不足的情况。</p>
<ul>
<li>方法</li>
</ul>
<div class="codehilite"><pre> Executors：线程池创建工厂类
 public static ExecutorServicenewFixedThreadPool(int nThreads)：返回线程池对象
 ExecutorService：线程池类
 Future&lt;?&gt; submit(Runnable task)：获取线程池中的某一个线程对象，并执行
 Future 接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用
</pre></div>

<ul>
<li>使用Runnable创建线程池</li>
</ul>
<p>1、创建线程池对象</p>
<p>2、创建 Runnable 接口子类对象</p>
<p>3、提交 Runnable 接口子类对象</p>
<p>4、关闭线程池</p>
<div class="codehilite"><pre><span class="c1">//Test.java</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建线程池对象  参数5，代表有5个线程的线程池</span>
        <span class="n">ExecutorService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="c1">//创建Runnable线程任务对象</span>
        <span class="n">TaskRunnable</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TaskRunnable</span><span class="o">();</span>
        <span class="c1">//从线程池中获取线程对象</span>
        <span class="n">service</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;----------------------&quot;</span><span class="o">);</span>
        <span class="c1">//再获取一个线程对象</span>
        <span class="n">service</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="c1">//关闭线程池</span>
        <span class="n">service</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<div class="codehilite"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TaskRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;自定义线程任务在执行&quot;</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h1 id="4">4、网络编程<a class="headerlink" href="#4" title="Permanent link"></a></h1>
<h2 id="41-tcp">4.1 TCP连接过程<a class="headerlink" href="#41-tcp" title="Permanent link"></a></h2>
<p>服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</p>
<p>服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</p>
<p>服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。</p>
<p>Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</p>
<p>在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。</p>
<h2 id="42">4.2 方法<a class="headerlink" href="#42" title="Permanent link"></a></h2>
<h3 id="421-serversocket">4.2.1 ServerSocket类<a class="headerlink" href="#421-serversocket" title="Permanent link"></a></h3>
<p>服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。</p>
<ul>
<li>构造方法</li>
</ul>
<p>|1 |<strong>public ServerSocket(int port) throws IOException</strong>
创建<strong>绑定</strong>到特定端口的服务器套接字。|
|-|-|
|2 | <strong>public ServerSocket(int port, int backlog) throws IOException</strong>
利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。|
|-|-|
|3 | <strong>public ServerSocket(int port, int backlog, InetAddress address) throws IOException</strong>
使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。|
|-|-|
|4| <strong>public ServerSocket() throws IOException</strong>
创建非绑定服务器套接字。|</p>
<p>说明：创建非绑定服务器套接字。 如果 ServerSocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。</p>
<ul>
<li>常用方法</li>
</ul>
<p>|1 |<strong>public int getLocalPort()</strong>
  返回此套接字在其上侦听的端口。|
|-|-|
|2 |<strong>public Socket accept() throws IOException</strong>
侦听并接受到此套接字的连接。|
|-|-|
|3 |<strong>public void setSoTimeout(int timeout)</strong>
 通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。|
 |-|-|
|4 |<strong>public void bind(SocketAddress host, int backlog)</strong>
将 ServerSocket 绑定到特定地址（IP 地址和端口号）。|</p>
<h3 id="422-socket">4.2.2 Socket类<a class="headerlink" href="#422-socket" title="Permanent link"></a></h3>
<p>java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。</p>
<ul>
<li>构造方法</li>
</ul>
<p>|1 |<strong>public Socket(String host, int port) throws UnknownHostException, IOException.</strong>
创建一个流套接字并将其连接到指定主机上的指定端口号。|
|-|-|
|2 |<strong>public Socket(InetAddress host, int port) throws IOException</strong>
创建一个流套接字并将其连接到指定 IP 地址的指定端口号。|
|-|-|
|3 |<strong>public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException.</strong>
创建一个套接字并将其连接到指定远程主机上的指定远程端口。|
|-|-|
|4 |<strong>public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException.</strong>
创建一个套接字并将其连接到指定远程地址上的指定远程端口。|
|-|-|
|5 |<strong>public Socket()</strong>
通过系统默认类型的 SocketImpl 创建未连接套接字|</p>
<ul>
<li>常用方法</li>
</ul>
<p>|1 |<strong>public void connect(SocketAddress host, int timeout) throws IOException</strong>
将此套接字连接到服务器，并指定一个超时值。|
|-|-|
|2 |<strong>public InetAddress getInetAddress()</strong>
 返回套接字连接的地址。|
 |-|-|
|3 |<strong>public int getPort()</strong>
返回此套接字连接到的远程端口。|
|-|-|
|4 |<strong>public int getLocalPort()</strong>
返回此套接字绑定到的本地端口。|
|-|-|
|5 |<strong>public SocketAddress getRemoteSocketAddress()</strong>
返回此套接字连接的端点的地址，如果未连接则返回 null。|
|-|-|
|6 |<strong>public InputStream getInputStream() throws IOException</strong>
返回此套接字的输入流。|
|-|-|
|7 |<strong>public OutputStream getOutputStream() throws IOException</strong>
返回此套接字的输出流。|
|-|-|
|8 |<strong>public void close() throws IOException</strong>
关闭此套接字。|</p>
<h3 id="423-inetaddress">4.2.3 InetAddress类<a class="headerlink" href="#423-inetaddress" title="Permanent link"></a></h3>
<p>这个类表示互联网协议(IP)地址。</p>
<p>|1 |<strong>static InetAddress getByAddress(byte[] addr)</strong>
在给定原始 IP 地址的情况下，返回 InetAddress 对象。|
|-|-|
|2 |<strong>static InetAddress getByAddress(String host, byte[] addr)</strong>
根据提供的主机名和 IP 地址创建 InetAddress。|
|-|-|
|3 |<strong>static InetAddress getByName(String host)</strong>
在给定主机名的情况下确定主机的 IP 地址。|
|-|-|
|4 |<strong>String getHostAddress()</strong>
返回 IP 地址字符串（以文本表现形式）。|
|-|-|
|5 |<strong>String getHostName()</strong>
 获取此 IP 地址的主机名。|
 |-|-|
|6 |<strong>static InetAddress getLocalHost()</strong>
返回本地主机。|
|-|-|
|7 |<strong>String toString()</strong>
将此 IP 地址转换为 String。|</p>
<h2 id="43">4.3 实例<a class="headerlink" href="#43" title="Permanent link"></a></h2>
<div class="codehilite"><pre><span class="c1">//客户端</span>
<span class="c1">// 文件名 GreetingClient.java</span>

<span class="kn">import</span> <span class="nn">java.net.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreetingClient</span>
<span class="o">{</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
   <span class="o">{</span>
      <span class="n">String</span> <span class="n">serverName</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
      <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span><span class="c1">//将字符串转成int</span>
      <span class="k">try</span>
      <span class="o">{</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;连接到主机：&quot;</span> <span class="o">+</span> <span class="n">serverName</span> <span class="o">+</span> <span class="s">&quot; ，端口号：&quot;</span> <span class="o">+</span> <span class="n">port</span><span class="o">);</span>
         <span class="n">Socket</span> <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Socket</span><span class="o">(</span><span class="n">serverName</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span><span class="c1">//创建一个socket</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;远程主机地址：&quot;</span> <span class="o">+</span> <span class="n">client</span><span class="o">.</span><span class="na">getRemoteSocketAddress</span><span class="o">());</span><span class="c1">//获取远程socket的地址</span>
         <span class="n">OutputStream</span> <span class="n">outToServer</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span><span class="c1">//</span>
         <span class="n">DataOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataOutputStream</span><span class="o">(</span><span class="n">outToServer</span><span class="o">);</span>

         <span class="n">out</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="s">&quot;Hello from &quot;</span> <span class="o">+</span> <span class="n">client</span><span class="o">.</span><span class="na">getLocalSocketAddress</span><span class="o">());</span>
         <span class="n">InputStream</span> <span class="n">inFromServer</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span><span class="c1">//返回此套接字的输入流</span>
         <span class="n">DataInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataInputStream</span><span class="o">(</span><span class="n">inFromServer</span><span class="o">);</span><span class="c1">//数据流</span>
         <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;服务器响应： &quot;</span> <span class="o">+</span> <span class="n">in</span><span class="o">.</span><span class="na">readUTF</span><span class="o">());</span>
         <span class="n">client</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
      <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span>
      <span class="o">{</span>
         <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<div class="codehilite"><pre><span class="c1">//服务器</span>
<span class="c1">// 文件名 GreetingServer.java</span>

<span class="kn">import</span> <span class="nn">java.net.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreetingServer</span> <span class="kd">extends</span> <span class="n">Thread</span>
<span class="o">{</span>
   <span class="kd">private</span> <span class="n">ServerSocket</span> <span class="n">serverSocket</span><span class="o">;</span>

   <span class="kd">public</span> <span class="nf">GreetingServer</span><span class="o">(</span><span class="kt">int</span> <span class="n">port</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span>
   <span class="o">{</span>
      <span class="n">serverSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServerSocket</span><span class="o">(</span><span class="n">port</span><span class="o">);</span><span class="c1">//创建socket并绑定到特定的端口</span>
      <span class="n">serverSocket</span><span class="o">.</span><span class="na">setSoTimeout</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span>
   <span class="o">{</span>
      <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
      <span class="o">{</span>
         <span class="k">try</span>
         <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;等待远程连接，端口号为：&quot;</span> <span class="o">+</span> <span class="n">serverSocket</span><span class="o">.</span><span class="na">getLocalPort</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;...&quot;</span><span class="o">);</span>
            <span class="n">Socket</span> <span class="n">server</span> <span class="o">=</span> <span class="n">serverSocket</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;远程主机地址：&quot;</span> <span class="o">+</span> <span class="n">server</span><span class="o">.</span><span class="na">getRemoteSocketAddress</span><span class="o">());</span>
            <span class="n">DataInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataInputStream</span><span class="o">(</span><span class="n">server</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">());</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">readUTF</span><span class="o">());</span><span class="c1">//如果接受纯数据的话，这里不能用readUTF</span>
            <span class="n">DataOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataOutputStream</span><span class="o">(</span><span class="n">server</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">());</span>
            <span class="n">out</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="s">&quot;谢谢连接我：&quot;</span> <span class="o">+</span> <span class="n">server</span><span class="o">.</span><span class="na">getLocalSocketAddress</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;\nGoodbye!&quot;</span><span class="o">);</span>
            <span class="n">server</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
         <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">SocketTimeoutException</span> <span class="n">s</span><span class="o">)</span>
         <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Socket timed out!&quot;</span><span class="o">);</span>
            <span class="k">break</span><span class="o">;</span>
         <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span>
         <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="k">break</span><span class="o">;</span>
         <span class="o">}</span>
      <span class="o">}</span>
   <span class="o">}</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
   <span class="o">{</span>
      <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
      <span class="k">try</span>
      <span class="o">{</span>
         <span class="n">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GreetingServer</span><span class="o">(</span><span class="n">port</span><span class="o">);</span>
         <span class="n">t</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
      <span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span>
      <span class="o">{</span>
         <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h2 id="44">4.4 名词<a class="headerlink" href="#44" title="Permanent link"></a></h2>
<ul>
<li>同步和异步</li>
</ul>
<p>同步指的是用户进程触发IO 操作并等待或者轮询的去查看IO 操作是否就绪</p>
<p>异步是指用户进程触发IO 操作以后便开始做自己的事情，而当IO 操作已经完成的时候会得到IO 完成的通知。</p>
<ul>
<li>阻塞与非阻塞</li>
</ul>
<p>阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式</p>
<p>阻塞方式下读取或者写入函数将一直等待</p>
<p>非阻塞方式下，读取或者写入方法会立即返回一个状态值</p>
<ul>
<li>BIO 编程</li>
</ul>
<p>Blocking IO： 同步阻塞的编程方式。</p>
<p>JDK1.4版本之前常用的编程方式。首先在服务端启动一个ServerSocket来监听网络请求，客户端启动Socket发起网络请求，默认情况下ServerSocket回建立一个线程来处理此请求，如果服务端没有线程可用，客户端则会阻塞等待或遭到拒绝。</p>
<p>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p>
<ul>
<li>NIO 编程</li>
</ul>
<p>Unblocking IO（New IO）： 同步非阻塞的编程方式</p>
<p>NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题，NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。</p>
<p>NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，<strong>发现连接上有请求的话，才开启一个线程进行处理</strong>，也就是一个请求一个线程模式。</p>
<ul>
<li>AIO编程</li>
</ul>
<p>Asynchronous IO： 异步非阻塞的编程方式。</p>
<p>对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。</p>
<h1 id="java">java备忘<a class="headerlink" href="#java" title="Permanent link"></a></h1>
<h2 id="_1">方法的型参和实参<a class="headerlink" href="#_1" title="Permanent link"></a></h2>
<p>java中只能实现值传递，不能引用传递，和CPP不同。</p>
<p>所以无法通过方法直接改变，可以通过return来返回改变后的值。</p>
<p>注意：如果是基本类型或者String，实参不会改变，传的是值。如果是对象集合或者数组，则实参会改变，传的是引用。</p>
<h2 id="_2">构造方法<a class="headerlink" href="#_2" title="Permanent link"></a></h2>
<p>构造方法和他所在类的名字相同，当构造方法没有返回值。</p>
<p>所有类都有构造方法，Java自动提供了一个默认构造方法，它把所有成员初始化为0。</p>
<p>一旦定义了自己的构造方法，默认构造方法失效。</p>
<h2 id="_3">数组<a class="headerlink" href="#_3" title="Permanent link"></a></h2>
<p>存储在<em>堆</em>上的对象</p>
<h2 id="_4">继承<a class="headerlink" href="#_4" title="Permanent link"></a></h2>
<p>超类（super class）：被继承的类</p>
<p>子类（subclass）：派生类</p>
<h2 id="_5">命名<a class="headerlink" href="#_5" title="Permanent link"></a></h2>
<p>package：全部小谢，eg.com.runoob。</p>
<p>class和interface：大写字母开头，多个单词时，第二个单词开始开头大写。。</p>
<p>class变量：小写字母开头，多个单词时，第二个单词开始开头大写。</p>
<h2 id="_6">源文件声明规则<a class="headerlink" href="#_6" title="Permanent link"></a></h2>
<p>1、源文件中只能有一个public类，可以有多个非public类</p>
<p>2、源文件名和public类名相同</p>
<p>3、如果一个类定义在某个包中，package语句应该在源文件的首行。</p>
<p>4、源文件的import语句在package语句和类定义之间。</p>
<p>5、import语句和package语句堆源文件中定义的所有类都有效。在同一个源文件中，不能给不同的类不同的包声明。</p>
<h2 id="_7">堆和栈<a class="headerlink" href="#_7" title="Permanent link"></a></h2>
<h3 id="_8">概述<a class="headerlink" href="#_8" title="Permanent link"></a></h3>
<p>JVM内存的划分：</p>
<ol>
<li>
<p>寄存器；</p>
</li>
<li>
<p>本地方法区；</p>
</li>
<li>
<p>方法区；</p>
</li>
<li>
<p>栈内存；</p>
</li>
<li>
<p>堆内存。</p>
</li>
</ol>
<ul>
<li>栈内存</li>
</ul>
<p>栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。</p>
<ul>
<li>堆内存</li>
</ul>
<p>存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。</p>
<h3 id="_9">解析<a class="headerlink" href="#_9" title="Permanent link"></a></h3>
<p>主函数先进栈，在栈中定义一个变量arr,接下来为arr赋值，但是右边不是一个具体值，是一个实体。实体创建在堆里，在堆里首先通过new关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的，但在堆里是可以用的，因为初始化过了，但是在栈里没有），不同的类型初始化的值不一样。所以堆和栈里就创建了变量和实体：</p>
<p><img src="/images/wiki/Netty/DuiZhanyingshe.jpg" width="700" alt="堆栈的关联" /></p>
<p>当一个实体，没有引用数据类型指向的时候，它在堆内存中不会被释放，而被当做一个垃圾，在不定时的时间内自动回收，因为Java有一个自动回收机制，（而c++没有，需要程序员手动回收，如果不回收就越堆越多，直到撑满内存溢出，所以Java在内存管理上优于c++）。自动回收机制（程序）自动监测堆里是否有垃圾，如果有，就会自动的做垃圾回收的动作，但是什么时候收不一定。</p>
<ul>
<li>区别总结</li>
</ul>
<p>1.栈内存存储的是局部变量而堆内存存储的是实体；</p>
<p>2.栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p>
<p>3.栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p>
<h3 id="_10">线程安全<a class="headerlink" href="#_10" title="Permanent link"></a></h3>
<ul>
<li>多线程的三个概念</li>
</ul>
<p>1</p></article></body></html>