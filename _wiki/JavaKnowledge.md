---
layout: wiki
title: Java知识点
categories: Java
description: Java的知识点
keywords: Linux
---

### **java中==和equals和hashCode的区别？**

1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；

　如果作用于引用类型的变量，则比较的是所指向的对象的地址

2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量

　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；

　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。

3）hashCode是得到哈希值，往往用于判断两个数是否不同。

  如在集合中，每个元素都不相同，则先通过哈希值映射到特定值，如果没有那么说明还没有相同的数插入；如果已经有了相同的哈希值，也不能说明集合中有了相同的数，需要通过.equals来判断。

### **什么是内部类？内部类的作用**

将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。

作用：1、每个内部类可以单独继承父类，使得java也实现了多继承；2、包含一定逻辑关系的类组织在一起，方便隐藏；3、方便编写事件驱动程序；4、方便编写线程代码

### **java的(PO,VO,TO,BO,DAO,POJO)解释**

**PO**

persistant object持久对象

最形象的理解就是一个PO就是数据库中的一条记录。

好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。

**BO**

business object:业务对象

主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。

比如一个简历，有教育经历、工作经历、社会关系等等。

我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。

建立一个对应简历的BO对象处理简历，每个BO包含这些PO。

这样处理业务逻辑时，我们就可以针对BO去处理。

**VO **

value object值对象

ViewObject表现层对象

主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值。

**DTO **

Data Transfer Object:数据传输对象

主要用于远程调用等需要大量传输对象的地方。

比如我们一张表有100个字段，那么对应的PO就有100个属性。

但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO

**POJO **

plain ordinary java object 简单java对象

个人感觉POJO是最常见最多变的对象，是一个中间对象，也是我们最常打交道的对象。

一个POJO持久化（即将程序数据保存到硬件系统重启可恢复）以后就是PO，直接用它传递、传递过程中就是DTO，直接用来对应表示层就是VO

**DAO**

data access object数据访问对象

这个大家最熟悉，和上面几个O区别最大，基本没有互相转化的可能性和必要.

主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO

### **什么是JPA**

JPA(Java Persistence API)是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。他的出现主要是为了简化现有的持久化开发工作和整合ORM技术，结束现在Hibernate，TopLink，JDO等ORM框架各自为营的局面。值得注意的是，JPA是在充分吸收了现有Hibernate，TopLink，JDO等ORM框架的基础上发展而来的，具有易于使用，伸缩性强等优点。从目前的开发社区的反应上看，JPA受到了极大的支持和赞扬，其中就包括了Spring与EJB3.0的开发团队。着眼未来几年的技术走向，JPA作为ORM领域标准化整合者的目标应该不难实现。

JPA的总体思想和现有Hibernate,TopLink,JDO等ORM框架大体一致。总的来说，JPA包括以下3方面的技术：

• **ORM映射元数据**

JPA支持XML和JDK5.0注释(也可译作注解)两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。

• **Java持久化API**

用来操作实体对象，执行CRUD操作，框架在后台替我们完成所有的事情，开发者可以从繁琐的JDBC和SQL代码中解脱出来。

• **查询语言（JPQL）**

这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序的SQL语句紧密耦合。

### 什么是ORM

ORM（Object-Relation Mapping）是对象-关系映射，当下流行的开发语言都是面向对象的，如Java，C#。而当下流行的DB大多都是面向关系的，也就是关系数据库。这样在面向对象与面向关系之间需要一个桥梁，才能使二者协同无缝联合工作，ORM就是这个桥梁。映射关系如下：

​    `[类]<=>[表]  [对象实例]<=>[表的行]  [属性]<=>[表的列]`

那么这些映射关系是如何制定的呢？——只需要一个映射文件（XML）即可，在其中配置持久化类与DB表的映射关系后，ORM中间件在运行时参照此文件内容，对象持久化的DB中或把DB中数据加载到持久化类中。

Hibernate就是一个卓越的ORM中间件。

### extends和implements区别

　`extends`可以理解为全盘继承了父类的功能。`implements`可以理解为为这个类附加一些额外的功能；`interface`定义一些方法,并没有实现,需要`implements`来实现才可用。`extend`可以继承一个接口,但仍是一个接口,也需要`implements`之后才可用。对于`class`而言，`extends`用于(单)继承一个类（`class`），而`implements`用于实现一个接口(`interface`)。

### 乐观锁和悲观锁

**悲观锁**

悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。

**乐观锁**

乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

乐观锁一般来说有以下2种方式：

1. 使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。
2. 使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。